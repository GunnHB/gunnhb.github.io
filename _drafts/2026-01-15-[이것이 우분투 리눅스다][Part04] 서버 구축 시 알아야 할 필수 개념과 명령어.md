---
title: "[이것이 우분투 리눅스다][Part04] 서버 구축 시 알아야 할 필수 개념과 명령어_1"
description: 리눅스 운영에 필요한 개념과 명령어에 대해 알아보자
date: 2026-01-15 00:00:00 +09:00
categories: [Textbook, Ubuntu, Linux]
tags:
  [
    ComputerScience,
    Textbook,
    Linux
  ]
use_math: true
---

![](/assets/img/post/Textbook/Ubuntu%20Linux/ubuntu_linux.jpg)

> 🔔 [[한빛미디어]이것이 우분투 리눅스다](https://www.hanbit.co.kr/store/books/look.php?p_code=B3658372395)를 정리한 내용입니다. 🔔
{: .prompt-info}

## 리눅스 운영에서 먼저 알아야 할 개념
### 시작과 종료
`Ubuntu Desktop`나 `Ubuntu Budgie`를 부팅하면 X 윈도우가 자동으로 실행된다.

> **X 윈도우<sup>X Window System</sup>**는 리눅스에 GUI를 제공하는 유틸리티이다.(그래픽 모드) 편의를 위한 것이기에 반드시 사용할 필요는 없다.
{: .prompt-info}

X 윈도우 환경에서는 Windows와 똑같이 종료 아이콘을 통해 컴퓨터를 종료할 수 있다.

터미널이나 콘솔에서의 시스템 종료 명령어들은 다음과 같다.
```bash
poweroff
shutdown -P now
halt -p
init 0
```

`shutdown` 명령어 옵션 중 `now` 부분에 시간을 지정하면 지정한 시간에 시스템을 종료한다.

```bash
shutdown -P +10     # 10분 후 종료
shutdown -r 22:00   # 오후 10시에 재부팅 (r: reboot)
shutdown -c         # 예약된 sbutdown 취소 (c: cancel)
shutdown -k +15     # 현재 접속한 사용자에게 15분 후 종료된다는 메시지를 보내지만 실제 종료되진 않음
```

### 시스템 재부팅
X 윈도우에서는 [다시 시작] 버튼을 통해 재부팅한다.

명령어를 통해 재부팅하려면 터미널에서 다음과 같이 입력하면 된다.

```bash
reboot
shutdown -r now
init 6
```

### 로그아웃
리눅스는 다중 사용자<sup>Multi-User</sup> 시스템이므로 자신만 접속을 끊는 로그아웃이 필요하다. X 윈도우에서 로그아웃하려면 [로그아웃] 버튼을 선택하면 되며, 터미널에서는 `logout` 또는 `exit` 명령을 실행한다.

### 가상 콘솔
**가상 콘솔**이란 하나의 시스템에서 독립적으로 동작하는 가상의 작업 공간이다. 우분투는 총 5개(2~6번)의 가상 콘솔을 제공하며, 단축키를 통해 자유롭게 오갈 수 있다.

`Ubuntu Desktop`을 부팅하면 X 윈도우가 자동으로 실행된다. 이 화면이 2번 가상 콘솔이며, 3~6번의 가상 콘솔은 텍스트 모드로 제공된다.

> 가상 콘솔 전환 단축키: `Ctrl` + `Alt` + `F2` ~ `F6`
{: .prompt-tip}

그렇다면 가상 콘솔은 왜 있는걸까? 시스템 관리 중 그래픽 환경(X 윈도우)이 멈추거나 입력이 불가능한 비상 상황에 대비하기 위함이다. 이때 시스템을 강제로 종료(전원 차단)하는 대신, 가상 콘솔로 이동하여 문제를 일으킨 프로세스를 종료하거나 복구한 뒤 다시 그래픽 모드로 안전하게 돌아올 수 있다.

### 리눅스 디렉토리 구조와 명령어
Windows의 [파일 탐색기]를 통해 폴더 구조를 확인해보면 `C:\`부터 하위 디렉토리가 연결된 구조인 것을 확인할 수 있다.

리눅스도 비슷하다. `tree` 명령어 등을 통해 구조를 확인해보면 **/<sup>루트 디렉토리</sup>**라는 최상위 디렉토리 아래에 하위 디렉토리가 연결된 구조인 것을 확인할 수 있다.

Windows 환경에서의 경로 구분은 **역슬래시(\\)**이지만 리눅스 환경에서의 경로 구분은 **슬래시(/)**이다.
{: .prompt-tip}

리눅스에서 자주 사용하는 명령어를 정리하면 다음과 같다.

- **`ls`**
  - ***List***의 약자로, 해당 디렉토리에 있는 파일의 목록을 나열한다.

```bash
ls                      # 현재 디렉토리의 파일 목록
ls /etc/systemd         # /etc/systemd 디렉토리의 목록
ls -a                   # 현재 디렉토리의 목록 (숨김 파일 포함)
ls -l                   # 현재 디렉토리의 목록을 자세히 보여줌
ls *.conf               # 확장자가 conf인 목록을 보여줌
ls -l /etc/systemd/n*   # /etc/systemd 디렉토리에 있는 목록 중 앞 글자가 'n'인 것의 목록을 자세히 보여줌
```

- **`cd`**
  - ***Change Directory***의 약자로 디렉토리를 이동하는 명령어

```bash
cd                      # 현재 사용자의 홈 디렉토리로 이동 (만약 사용자가 root면 /root 디렉토리로 이동)
cd ~ubuntu              # ubuntu 사용자의 홈 디렉토리로 이동
cd ..                   # 바로 상위의 디렉토리로 이동
cd /etc/systemd         # /etc/systemd 디렉토리로 이동 (절대 경로)
cd ../etc/systemd       # 상대 경로로 이동 (현재 디렉토리의 상위로 이동한 뒤 /etc/systemd로 이동)
```

- **`pwd`**
  - ***Print Working Directory***의 약자로 현재 디렉토리의 전체 경로를 화면에 보여준다.

```bash
pwd   # 현재 작업 중인 디렉토리의 경로 출력
```

- **`touch`**
  - 크기가 0인 **새 파일을 생성**하거나 이미 파일이 존재한다면 **파일의 최종 수정 시간을 변경**한다.

```bash
touch abc.txt  # 파일이 없으면 abc.txt라는 빈 파일을 생성하고, 파일이 있으면 파일의 최종 수정 시간을 현재 시각으로 변경
```

- **`rm`**
  - ***Remove***의 약자로 파일이나 디렉토리를 삭제한다. 삭제할 때는 현재 사용자에게 파일이나 디렉토리를 삭제할 권한이 있어야 한다.
  - 단, root 사용자는 모든 권한이 있으므로 이 **명령에 제약이 없다.**

```bash
rm abc.txt      # 해당 파일 삭제 (내부적으로는 rm -f로 연결됨)
rm -i abc.txt   # 삭제 시 확인 메시지가 나옴
rm -f abc.txt   # 확인 메시지 없이 바로 삭제 (f: Force)
rm -rf abc      # abc 디렉토리와 그 아래에 있는 하위 디렉토리를 강제로 전부 삭제 (r: Recursive)
```

- **`cp`**
  - ***Copy***의 약자로 파일이나 디렉토리를 복사한다.
  - 새로 복사한 파일은 복사한 사용자의 소유가 된다. 그러므로 명령을 실행하는 사용자는 해당 파일의 **읽기 권한이 필요**하다.

```bash
cp abc.txt cba.txt  # abc.txt를 cba.txt라는 이름으로 바꿔서 복사
cp -r abc cba       # 디렉토리를 복사 (abc 디렉토리를 cba 디렉토리로 복사)
```

- **`mv`**
  - ***Move***의 약자로 **파일이나 디렉토리의 이름을 변경**하거나 **다른 디렉토리로 옮길 때 사용**한다.

```bash
mv abc.txt /etc/systemd/   # abc.txt를 /etc/systemd/ 디렉토리로 이동 
mv aaa bbb ccc ddd         # aaa, bbb, ccc, 파일을 /ddd 디렉토리로 이동 
mv abc.txt. www.txt        # abc.txt의 이름을 www.txt로 변경
```

- **`mkdir`**
  - ***Make Directory***의 약자로 새로운 디렉토리를 생성한다.
  - 생성한 디렉토리는 명령을 실행한 사용자의 소유가 된다.

```bash
mkdir abc           # 현재 디렉토리 아래에 '/abc'라는 디렉토리 생성
mkdir -p /def/fgh   # /def/fgh 디렉토리를 생성하는데 만약 /fgh 디렉토리의 부모 디렉토리인 /def 디렉토리가 없다면 자동 생성해줌 (p: Parents)
```

- **`rmdir`**
  - ***Remove Directory***의 약자로 디렉토리를 삭제한다.
  - 해당 디렉토리의 삭제 권한이 있어야 하며, 디렉토리는 비어있어야 한다.
  - 파일이 있는 디렉토리를 삭제하려면 `rm -r` 명령을 실행해야 한다.

```bash
rmdir abc   # abc 디렉토리 삭제
```

- **`cat`**
  - ***ConCatenate***의 약자로 파일 내용을 화면에 보여준다.
  - 여러 개의 파일을 나열하면 파일을 연결해서 보여준다.

```bash
cat a.txt b.txt   # a.txt와 b.txt를 연결해서 파일의 내용을 화면에 보여줌
```

- **`head`**, **`tail`**
  - 텍스트 형식으로 작성된 파일의 앞 10행 또는 마지막 10행만 화면에 출력한다.

```bash
head /etc/systemd/user.conf       # 해당 파일의 앞 10행을 화면에 출력
head -3 /etc/systemd/user.conf    # 앞 3행만 화면에 출력
tail -5 /etc/systemd/user.conf    # 마지막 5행만 화면에 출력
```

- **`more`**
  - 텍스트 형식으로 작성된 파일을 페이지 단위로 화면에 출력한다.
  - `spacebar`키를 누르면 다음 페이지로 이동하며 `B`키를 누르면 이전 페이지로 이동한다.
  - `Q`를 누르면 종료한다.

```bash
more /etc/systemd/systemd/conf
more +10 /etc/systemd/system.conf   # 10행부터 출력
```

- **`less`**
  - more 명령어와 용도가 유사한 명령어
  - `PageUp`과 `PageDown`으로 페이지를 이동한다.

```bash
less /etc/systemd/system.conf
less +10 /etc/systemd.system.conf   # 10행부터 출력
```

- **`file`**
  - 해당 파일이 어떤 종류의 파일인지 표시해준다.

```bash
file /etc/systemd/system.conf   # system.conf는 텍스트 파일이므로 아스키 파일로 표시됨
file /bin/gzip                  # gzip은 실행 파일이므로 'ELF 64-bit LSB Shared Obejct' 파일로 표시됨
```

- **`clear`**
  - 현재 사용 중인 터미널 화면을 깨끗하게 지워준다.

```bash
clear
```

### 런레벨
시스템 종료 명령어 중 `init 0`과 재부팅 명령어 `init 6`이 있었다.`init` 명령어 뒤에 붙은 숫자는 **런레벨<sup>Runlevel</sup>**로, 리눅스는 시스템이 가동되는 방법을 7가지의 런레벨로 나눈다.

|런레벨|영문 모드|설명|비고|
|---|---|---|---|
|0|Power Off|종료 모드||
|1|Rescue|시스템 복구 모드||
|2|Multi-User||사용하지 않음|
|3|Multi-User|텍스트 모드의 다중 사용자 모드||
|4|Multi-User||사용하지 않음|
|5|Graphical|그래픽 모드의 다중 사용자 모드||
|6|Reboot|||

> 런레벨 모드를 확인하고 싶다면 `/lib/systemd/system` 디렉토리의 runlevel?.target 파일을 확인하면 된다. (?는 한 글자를 의미)
{: .prompt-tip}

결국 `init 0`은 '런레벨 0번으로 시스템을 전환하라'는 의미이며 `init 6`은 '즉시 재부팅하라'는 의미이다. 참고로 `Ubuntu Desktop`은 부팅 시 자동으로 X 윈도우가 시작되므로 런레벨 5번으로 지정되며, Ubuntu Server는 텍스트 모드로 실행되므로 런레벨이 3번으로 지정된다.

### 자동 완성과 히스토리
자동 완성은 파일 이름의 일부만 입력하고 `Tab`키를 눌러 나머지 파일 이름 또는 폴더 이름을 자동으로 완성하는 기능이다.

도스 키<sup>Dos Key</sup>란 `↑`/`↓`키를 통해 이전에 입력한 명령이 다시 나타나게 하는 것을 말한다.

### 에디터 사용
Windows의 메모장처럼 X 윈도우에서 제공하는 편리한 에디터로는 `gedit`이 있다. 터미널에서 `gedit 파일이름` 명령을 입력하면 해당 파일을 편집할 수 있다.

이보다 더 전통적인 것으로 `vi` 에디터가 있으며 모든 유닉스/리눅스 시스템에 기본적으로 포함되어 있다.

### 도움말 사용법
리눅스에는 엄청난 양의 명령어가 있다. 이를 모두 외울 수 없으니 man 명령을 통해 도움받을 수 있다. 사용 방법은 간단히 `man 명령어`를 사용하면 된다.

### 마운트와 CD/DVD, USB 활용
리눅스에서 하드디스크의 파티션, CD/DVD, USB 메모리 등을 사용하려면 지정한 위치에 연결해 줘야 한다. 이렇게 물리적인 장치를 특정한 위치(대개 폴더)에 연결시키는 과정을 '마운트'라고 한다.

```bash
mount     # 마운트된 장치 확인
umount    # 마운트된 장치 해제
```

### 리눅스에서 ISO 파일 생성
리눅스에는 명령을 통해 ISO 파일을 생성할 수 있다. 이를 위해서는 우선 패키지를 설치해야 한다.

```bash
apt -y install genisoimage  # 패키지 설치
```

ISO 파일을 생성은 `genisoimage -r -J -o 생성될ISO파일이름 포함될파일또는디렉토리` 형식으로 입력하면 된다.

```bash
genisoimage -r -J -o boot.iso /boot   # /boot 디렉토리의 모든 파일을 boot.iso파일로 만들어라
```

## 사용자와 그룹 관리
### 사용자와 그룹의 개념
리눅스는 **다중 사용자 시스템<sup>multi-user system</sup>**이다. 즉, 1대의 리눅스에 사용자 여러 명이 동시에 접속해서 사용할 수 있는 시스템이다.

리눅스를 처음 설치하면 기본적으로 root라는 이름을 가진 **슈퍼 유저<sup>super user</sup>**가 있다. root 사용자에게는 시스템의 모든 작업을 실행할 수 있는 권한이 있다. 또한 시스템에 접속할 수 있는 사용자를 생성할 수 있는 권한도 있다.

추가로 모든 사용자는 혼자서 존재하는 것이 아닌 하나 이상의 그룹에 소속되어 있어야 한다.

> 회사의 직원이 부서에 소속되는 것과 유사하다.
{: .prompt-info}

```bash
vi /etc/passwd
```

명령을 통해 파일을 열면 사용자 목록이 나오게 된다. ubuntu 사용자를 이용해 구성을 분석하면 다음과 같다. 

> ubuntu:x:1000:1000:ubuntu:/home/ubuntu:/bin/bash<br>
사용자 이름:암호:사용자 id:사용자가 소속된 그룹 id:추가 정보:홈 디렉토리:기본 셸

**[사용자 이름]**은 ubuntu이며, **[암호]**가 x로 표시되는 것은 `/etc/shadow` 파일에 비밀번호가 저장되어 있다는 뜻이다. 

**[사용자의 id]**는 1000번이며 **[사용자가 속한 그룹의 id]**는 1000번이다.

**[추가 정보]**는 '전체 이름, 사무실 호수, 직장 전화번호, 집 전화번호, 기타'로 나타내는데 모두 생략 가능하다.

**[홈 디렉토리]**는 `/home/ubuntu`이고, 로그인 시 제공되는 **[셸]**은 `/bin/bash`이다.

다음으로 /etc/group 파일을 확인하자.

```bash
vi /etc/group
```

> ubuntu:x:1000:<br>
그룹 이름:비밀번호:그룹id:그룹에 속한 사용자 이름

**[그룹 이름]**은 ubuntu이다. 즉, ubuntu 사용자는 ubuntu 그룹에 속한 것이다.

**[비밀번호]**는 사용자와 마찬가지로 x로 표시된다.

**[그룹id]**는 1000번이다. 사용자 정보와 마찬가지로 ubuntu 사용자가 ubuntu 그룹에 속한 것을 의미한다.

**[그룹에 속한 사용자 이름]**은 참조로 사용된다. 즉, 해당 부분이 비어있더라도 그룹에 소속된 사용자가 반드시 없다는 뜻은 아니다.