---
title: "[혼공컴운][Ch02] Section 01.0과 1로 숫자를 표현하는 방법"
description: 숫자를 표현하는 다양한 방법
date: 2025-03-09 00:00:00 +09:00
categories: [Textbook, ComputerArchitecture & OperatingSystems]
tags:
  [
    ComputerScience,
    Textbook,
    Data,
    Binary,
    Hexadecimal,
  ]
use_math: true
---

> 🔔 [[한빛미디어]혼자 공부하는 컴퓨터 구조+운영체제](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)를 정리한 내용입니다. 🔔
{: .prompt-info}

## 개요
컴퓨터는 **0과 1로 모든 정보를 표현**하고, **0과 1로 표현된 정보만을 이해**할 수 있다. 그런데 어떻게 3 + 4의 결과가 7이라는 것을 도출해낼 수 있을까? 이번 절에서는 컴퓨터가 표현하는 **정보 단위**와 0과 1만으로 숫자를 표현하는 방법에 대해 알아보자.

## 정보 단위
컴퓨터가 이해하는 가장 작은 정보 단위를 **비트bit**라고 한다. 이는 0과 1을 나타내는 단위로써 전구에 빗대어 생각해보면 **켜진 상태를 1**, **꺼진 상태를 0**으로 표현하는 것이다.

그럼 2비트는 몇 개의 정보를 표현할 수 있을까?

| OFF | OFF |
| <font color='red'>ON</font> | OFF |
| OFF | <font color='red'>ON</font> |
| <font color='red'>ON</font> | <font color='red'>ON</font> |

위 표처럼 네 가지의 상태로 나타낼 수 있다. 그렇다면 3비트는 어떨까?

| OFF | OFF | OFF |
| <font color='red'>ON</font> | OFF | OFF |
| OFF | <font color='red'>ON</font> | OFF |
| OFF | OFF | <font color='red'>ON</font> |
| <font color='red'>ON</font> | <font color='red'>ON</font> | OFF |
| <font color='red'>ON</font> | OFF | <font color='red'>ON</font> |
| OFF | <font color='red'>ON</font> | <font color='red'>ON</font> |
| <font color='red'>ON</font> | <font color='red'>ON</font> | <font color='red'>ON</font> |

위와 같이 여덟 가지의 정보를 표현할 수 있다.

여기서 알 수 있듯 정보 단위는 n비트로 2<sup>n</sup>가지의 정보 표현이 가능하다. 그렇기 때문에 프로그램은 수많은 비트로 이루어져 있는 것이다. 하지만 비트는 최소 단위이기 때문에 프로그램의 크기를 말할 때는 편의를 위해 더 큰 단위를 사용한다.

| 1바이트(1byte) | 8비트(8bit) |
| 1킬로바이트(1kB) | 1,000바이트(1,000byte) |
| 1메가바이트(1MB) | 1,000킬로바이트(1,000kB) |
| 1기가바이트(1GB) | 1,000메가바이트(1,000MB) |
| 1테라바이트(1TB) | 1,000기가바이트(1,000GB) |

> 이전 단위를 1,024개씩 묶은 단위는 kiB, MiB, Gib,… 이다.
{: .prompt-info}

### 워드
**워드(word)**란 ***CPU가 한 번에 처리할 수 있는 데이터 크기***를 말한다. 만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 되는 것이고, 한 번에 32비트를 처리할 수 있다면 1워드는 32비트인 것이다.

이렇게 정의된 워드의 절반 크기를 **하프 워드(half word)**, 1배 크기를 **풀 워드(full word)**, 2배 크기를 **더블 워드(double word)**라고 한다.

## 이진법
**이진법binary**이란 ***0과 1로 수를 표현하는 방법***이다. 이를 이용하면 1보다 큰 수도 표현이 가능한데, 숫자가 1을 넘어가는 시점에 자리 올림을 하면 된다.

| **십진수** | **이진수** |
| --- | --- |
| 1 | 1 |
| 2 | 10 |
| 3 | 11 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |
| 8 | 1000 |

여기서 문제가 하나 발생하는데, 만약 10 + 1000이라는 수식을 두고 이게 십진법으로 나타낸 수인지, 이진법으로 나타낸 수인지를 구분할 수 없다는 것이다. 그렇기 때문에 이진법으로 나타낸 수일 경우 1000<sub>(2)</sub>로 나타내거나 이진수 앞에 0b를 붙이면 된다. 전자는 수학적으로 표기할 때, 후자는 코드 상에서 이진수를 표기할 때 사용한다.

### 이진수의 음수 표현
십진수의 음수 표현의 경우 단순히 숫자 앞에 마이너스 부호를 붙이면 된다. 이것은 이진수도 마찬가지일까? **컴퓨터는 0과 1만을 이해하므로 두 수를 이용해 음수를 표현해야 한다.**

0과 1로 음수를 표현하기 위해서는 **2의 보수two’s complement**를 구해 이 값을 음수로 간주한다. 2의 보수의 사전적 의미는 ‘어떤 수에서 그보다 큰 2<sup>n</sup>에서 뺀 값’을 의미한다. 하지만 2의 보수를 쉽게 구할 수 있는 방법이 있는데, **‘모든 0과 1을 뒤집고, 거기에 1을 더한 값’**으로 이해하면 된다.

> 이진수의 모든 0과 1을 뒤집은 수를 1의 보수, 거기에 1을 더한 값을 2의 보수라고 한다.
{: .prompt-info}

- 1011<sub>(2)</sub>의 음수 구하기
    - 모든 0과 1을 뒤집기
        - 0100<sub>(2)</sub>
    - 뒤집은 수에 1 더하기
        - 0101<sub>(2)</sub>
    - 1011<sub>(2)</sub>의 음수 == 0101<sub>(2)</sub>

그런데 0101<sub>(2)</sub>이 1011<sub>(2)</sub>의 음수인지, 십진수 5의 이진수인지 어떻게 구분할 수 있을까? 실제로 이진수만 봐서는 이 수가 음수인지 양수인지 구분하기 어렵다. CPU 내부에서는 어떤 수를 다룰 때 이 수가 양수인지 음수인지를 구분하기 위해 **플래그flag**를 사용한다. 플래그는 부가 정보를 의미하며, 컴퓨터 내부에서 숫자들은 ‘양수’ 혹은 ‘음수’가 적힌 표시들을 들고 다니므로 컴퓨터가 부호를 헷갈일 일은 없다 정도로만 이해하면 된다.

### 2의 보수의 한계

이진수의 음수를 표현하기 위해 2의 보수를 취하는 방식은 널리 사용되지만 완벽한 방법은 아니다. 0이나 2<sup>n</sup> 형태의 이진수에 2의 보수를 취하면 원하는 음수 값을 얻을 수 없다.

- 0의 2의 보수
    - 0 이진 표기
        - 0000<sub>(2)</sub>
    - 모든 0과 1 뒤집기
        - 1111<sub>(2)</sub>
    - 1 더하기
        - 10000<sub>(2)</sub> → 엉뚱한 값이 나옴

- 2<sup>3</sup>의 2의 보수
    - 2<sup>3</sup> 이진 표기
        - 1000<sub>(2)</sub>
    - 모든 0과 1 뒤집기
        - 0111<sub>(2)</sub>
    - 1 더하기
        - 1000<sub>(2)</sub> → 음수와 양수가 같음

즉, n비트로는 -2<sup>n</sup>과 2<sup>n</sup>이라는 수를 동시에 표현할 수 없다.

## 십육진법
이진법은 0과 1만으로 모든 숫자를 표현하다 보니 숫자의 길이가 너무 길어진다는 단점이 존재한다. 그렇기 때문에 컴퓨터의 데이터를 표현할 때 십육진법도 많이 사용되는데, **십육진법**은 ***수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식***이다.

십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기한다.

| 십진수 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| 십육진수 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |

> F 다음은 자리 올림으로 인해 10이 된다.
{: .prompt-info}

> 십육진수 역시 십진수와 구분하기 위해 숫자 뒤에 아래첨자 <sub>(16)</sub>을 붙이거나 숫자 앞에 0x를 붙인다.
{: .prompt-info}

그런데 굳이 십육진법을 사용하는 이유는 무엇일까? 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 **변환하기 쉽기 때문**이다.

### 십육진수를 이진수로 변환하기

우선 십육진수를 이루는 숫자 하나를 이진수로 표현하려면 몇 비트가 필요할까? 2<sup>4</sup> = 16이니 4비트가 필요하다.

십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한 글자를 4비트의 이진수로 간주하는 것이다. 즉, 십육진수를 이루고 있는 각 글자를 이진수로 변환하고, 그것들을 이어 붙이면 된다.

- 십육진수 1A2B<sub>(16)</sub>를 이진수로 변환하기
    - 각 글자를 이진수로 변환
        - 1<sub>(16)</sub> = 0001<sub>(2)</sub>
        - A<sub>(16)</sub> = 1010<sub>(2)</sub>
        - 2<sub>(16)</sub> = 0010<sub>(2)</sub>
        - B<sub>(16)</sub> = 1011<sub>(2)</sub>
    - 변환된 이진수 이어 붙이기
        - 0001101000101011<sub>(2)</sub>

### 이진수를 십육진수로 변환하기
반대로 이진수를 십육진수로 변환할 때는 이진수 숫자를 네 개씩 끊고, 끊어 준 네 개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어 붙이면 된다.

- 이진수 11010101<sub>(2)</sub>를 십육진수로 변환하기
    - 네 개씩 끊은 숫자를 십육진수로 변환
        - 1101<sub>(2)</sub> = D<sub>(16)</sub>
        - 0101<sub>(2)</sub> = 5<sub>(16)</sub>
    - 변환된 이진수
        - D5<sub>(16)</sub>

## 마무리
- **비트**는 0과 1로 표현할 수 있는 가장 작은 정보 단위이다.
- 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트는 비트보다 더 큰 정보단위이다.
- **이진법**은 1을 넘어가는 시점에 자리 올림을 하여 0과 1만으로 수를 표현하는 방법이다.
- 이진법에서 음수는 **2의 보수**로 표현할 수 있다.
- **십육진법**은 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법이다.