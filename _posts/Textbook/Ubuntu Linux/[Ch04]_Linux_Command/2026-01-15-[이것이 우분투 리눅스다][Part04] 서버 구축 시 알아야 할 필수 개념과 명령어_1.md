---
title: "[이것이 우분투 리눅스다][Part04] 서버 구축 시 알아야 할 필수 개념과 명령어_1"
description: 리눅스 운영에 필요한 개념과 명령어에 대해 알아보자
date: 2026-01-15 00:00:00 +09:00
categories: [Textbook, Ubuntu, Linux]
tags:
  [
    ComputerScience,
    Textbook,
    Linux
  ]
use_math: true
---

![](/assets/img/post/Textbook/Ubuntu%20Linux/ubuntu_linux.jpg)

> 🔔 [[한빛미디어]이것이 우분투 리눅스다](https://www.hanbit.co.kr/store/books/look.php?p_code=B3658372395)를 정리한 내용입니다. 🔔
{: .prompt-info}

## 리눅스 운영에서 먼저 알아야 할 개념
### 시작과 종료
`Ubuntu Desktop`나 `Ubuntu Budgie`를 부팅하면 X 윈도우가 자동으로 실행된다.

> **X 윈도우<sup>X Window System</sup>**는 리눅스에 GUI를 제공하는 유틸리티이다.(그래픽 모드) 편의를 위한 것이기에 반드시 사용할 필요는 없다.
{: .prompt-info}

X 윈도우 환경에서는 Windows와 똑같이 종료 아이콘을 통해 컴퓨터를 종료할 수 있다.

터미널이나 콘솔에서의 시스템 종료 명령어들은 다음과 같다.
```bash
poweroff
shutdown -P now
halt -p
init 0
```

`shutdown` 명령어 옵션 중 `now` 부분에 시간을 지정하면 지정한 시간에 시스템을 종료한다.

```bash
shutdown -P +10     # 10분 후 종료
shutdown -r 22:00   # 오후 10시에 재부팅 (r: reboot)
shutdown -c         # 예약된 sbutdown 취소 (c: cancel)
shutdown -k +15     # 현재 접속한 사용자에게 15분 후 종료된다는 메시지를 보내지만 실제 종료되진 않음
```

### 시스템 재부팅
X 윈도우에서는 [다시 시작] 버튼을 통해 재부팅한다.

명령어를 통해 재부팅하려면 터미널에서 다음과 같이 입력하면 된다.

```bash
reboot
shutdown -r now
init 6
```

### 로그아웃
리눅스는 다중 사용자<sup>Multi-User</sup> 시스템이므로 자신만 접속을 끊는 로그아웃이 필요하다. X 윈도우에서 로그아웃하려면 [로그아웃] 버튼을 선택하면 되며, 터미널에서는 `logout` 또는 `exit` 명령을 실행한다.

### 가상 콘솔
**가상 콘솔**이란 하나의 시스템에서 독립적으로 동작하는 가상의 작업 공간이다. 우분투는 총 5개(2~6번)의 가상 콘솔을 제공하며, 단축키를 통해 자유롭게 오갈 수 있다.

`Ubuntu Desktop`을 부팅하면 X 윈도우가 자동으로 실행된다. 이 화면이 2번 가상 콘솔이며, 3~6번의 가상 콘솔은 텍스트 모드로 제공된다.

> 가상 콘솔 전환 단축키: `Ctrl` + `Alt` + `F2` ~ `F6`
{: .prompt-tip}

그렇다면 가상 콘솔은 왜 있는걸까? 시스템 관리 중 그래픽 환경(X 윈도우)이 멈추거나 입력이 불가능한 비상 상황에 대비하기 위함이다. 이때 시스템을 강제로 종료(전원 차단)하는 대신, 가상 콘솔로 이동하여 문제를 일으킨 프로세스를 종료하거나 복구한 뒤 다시 그래픽 모드로 안전하게 돌아올 수 있다.

### 리눅스 디렉토리 구조와 명령어
Windows의 [파일 탐색기]를 통해 폴더 구조를 확인해보면 `C:\`부터 하위 디렉토리가 연결된 구조인 것을 확인할 수 있다.

리눅스도 비슷하다. `tree` 명령어 등을 통해 구조를 확인해보면 **/<sup>루트 디렉토리</sup>**라는 최상위 디렉토리 아래에 하위 디렉토리가 연결된 구조인 것을 확인할 수 있다.

Windows 환경에서의 경로 구분은 **역슬래시(\\)**이지만 리눅스 환경에서의 경로 구분은 **슬래시(/)**이다.
{: .prompt-tip}

리눅스에서 자주 사용하는 명령어를 정리하면 다음과 같다.

- **`ls`**
  - ***List***의 약자로, 해당 디렉토리에 있는 파일의 목록을 나열한다.

```bash
ls                      # 현재 디렉토리의 파일 목록
ls /etc/systemd         # /etc/systemd 디렉토리의 목록
ls -a                   # 현재 디렉토리의 목록 (숨김 파일 포함)
ls -l                   # 현재 디렉토리의 목록을 자세히 보여줌
ls *.conf               # 확장자가 conf인 목록을 보여줌
ls -l /etc/systemd/n*   # /etc/systemd 디렉토리에 있는 목록 중 앞 글자가 'n'인 것의 목록을 자세히 보여줌
```

- **`cd`**
  - ***Change Directory***의 약자로 디렉토리를 이동하는 명령어

```bash
cd                      # 현재 사용자의 홈 디렉토리로 이동 (만약 사용자가 root면 /root 디렉토리로 이동)
cd ~ubuntu              # ubuntu 사용자의 홈 디렉토리로 이동
cd ..                   # 바로 상위의 디렉토리로 이동
cd /etc/systemd         # /etc/systemd 디렉토리로 이동 (절대 경로)
cd ../etc/systemd       # 상대 경로로 이동 (현재 디렉토리의 상위로 이동한 뒤 /etc/systemd로 이동)
```

- **`pwd`**
  - ***Print Working Directory***의 약자로 현재 디렉토리의 전체 경로를 화면에 보여준다.

```bash
pwd   # 현재 작업 중인 디렉토리의 경로 출력
```

- **`touch`**
  - 크기가 0인 **새 파일을 생성**하거나 이미 파일이 존재한다면 **파일의 최종 수정 시간을 변경**한다.

```bash
touch abc.txt  # 파일이 없으면 abc.txt라는 빈 파일을 생성하고, 파일이 있으면 파일의 최종 수정 시간을 현재 시각으로 변경
```

- **`rm`**
  - ***Remove***의 약자로 파일이나 디렉토리를 삭제한다. 삭제할 때는 현재 사용자에게 파일이나 디렉토리를 삭제할 권한이 있어야 한다.
  - 단, root 사용자는 모든 권한이 있으므로 이 **명령에 제약이 없다.**

```bash
rm abc.txt      # 해당 파일 삭제 (내부적으로는 rm -f로 연결됨)
rm -i abc.txt   # 삭제 시 확인 메시지가 나옴
rm -f abc.txt   # 확인 메시지 없이 바로 삭제 (f: Force)
rm -rf abc      # abc 디렉토리와 그 아래에 있는 하위 디렉토리를 강제로 전부 삭제 (r: Recursive)
```

- **`cp`**
  - ***Copy***의 약자로 파일이나 디렉토리를 복사한다.
  - 새로 복사한 파일은 복사한 사용자의 소유가 된다. 그러므로 명령을 실행하는 사용자는 해당 파일의 **읽기 권한이 필요**하다.

```bash
cp abc.txt cba.txt  # abc.txt를 cba.txt라는 이름으로 바꿔서 복사
cp -r abc cba       # 디렉토리를 복사 (abc 디렉토리를 cba 디렉토리로 복사)
```

- **`mv`**
  - ***Move***의 약자로 **파일이나 디렉토리의 이름을 변경**하거나 **다른 디렉토리로 옮길 때 사용**한다.

```bash
mv abc.txt /etc/systemd/   # abc.txt를 /etc/systemd/ 디렉토리로 이동 
mv aaa bbb ccc ddd         # aaa, bbb, ccc, 파일을 /ddd 디렉토리로 이동 
mv abc.txt. www.txt        # abc.txt의 이름을 www.txt로 변경
```

- **`mkdir`**
  - ***Make Directory***의 약자로 새로운 디렉토리를 생성한다.
  - 생성한 디렉토리는 명령을 실행한 사용자의 소유가 된다.

```bash
mkdir abc           # 현재 디렉토리 아래에 '/abc'라는 디렉토리 생성
mkdir -p /def/fgh   # /def/fgh 디렉토리를 생성하는데 만약 /fgh 디렉토리의 부모 디렉토리인 /def 디렉토리가 없다면 자동 생성해줌 (p: Parents)
```

- **`rmdir`**
  - ***Remove Directory***의 약자로 디렉토리를 삭제한다.
  - 해당 디렉토리의 삭제 권한이 있어야 하며, 디렉토리는 비어있어야 한다.
  - 파일이 있는 디렉토리를 삭제하려면 `rm -r` 명령을 실행해야 한다.

```bash
rmdir abc   # abc 디렉토리 삭제
```

- **`cat`**
  - ***ConCatenate***의 약자로 파일 내용을 화면에 보여준다.
  - 여러 개의 파일을 나열하면 파일을 연결해서 보여준다.

```bash
cat a.txt b.txt   # a.txt와 b.txt를 연결해서 파일의 내용을 화면에 보여줌
```

- **`head`**, **`tail`**
  - 텍스트 형식으로 작성된 파일의 앞 10행 또는 마지막 10행만 화면에 출력한다.

```bash
head /etc/systemd/user.conf       # 해당 파일의 앞 10행을 화면에 출력
head -3 /etc/systemd/user.conf    # 앞 3행만 화면에 출력
tail -5 /etc/systemd/user.conf    # 마지막 5행만 화면에 출력
```

- **`more`**
  - 텍스트 형식으로 작성된 파일을 페이지 단위로 화면에 출력한다.
  - `spacebar`키를 누르면 다음 페이지로 이동하며 `B`키를 누르면 이전 페이지로 이동한다.
  - `Q`를 누르면 종료한다.

```bash
more /etc/systemd/systemd/conf
more +10 /etc/systemd/system.conf   # 10행부터 출력
```

- **`less`**
  - more 명령어와 용도가 유사한 명령어
  - `PageUp`과 `PageDown`으로 페이지를 이동한다.

```bash
less /etc/systemd/system.conf
less +10 /etc/systemd.system.conf   # 10행부터 출력
```

- **`file`**
  - 해당 파일이 어떤 종류의 파일인지 표시해준다.

```bash
file /etc/systemd/system.conf   # system.conf는 텍스트 파일이므로 아스키 파일로 표시됨
file /bin/gzip                  # gzip은 실행 파일이므로 'ELF 64-bit LSB Shared Obejct' 파일로 표시됨
```

- **`clear`**
  - 현재 사용 중인 터미널 화면을 깨끗하게 지워준다.

```bash
clear
```

### 런레벨
시스템 종료 명령어 중 `init 0`과 재부팅 명령어 `init 6`이 있었다.`init` 명령어 뒤에 붙은 숫자는 **런레벨<sup>Runlevel</sup>**로, 리눅스는 시스템이 가동되는 방법을 7가지의 런레벨로 나눈다.

|런레벨|영문 모드|설명|비고|
|---|---|---|---|
|0|Power Off|종료 모드||
|1|Rescue|시스템 복구 모드||
|2|Multi-User||사용하지 않음|
|3|Multi-User|텍스트 모드의 다중 사용자 모드||
|4|Multi-User||사용하지 않음|
|5|Graphical|그래픽 모드의 다중 사용자 모드||
|6|Reboot|||

> 런레벨 모드를 확인하고 싶다면 `/lib/systemd/system` 디렉토리의 runlevel?.target 파일을 확인하면 된다. (?는 한 글자를 의미)
{: .prompt-tip}

결국 `init 0`은 '런레벨 0번으로 시스템을 전환하라'는 의미이며 `init 6`은 '즉시 재부팅하라'는 의미이다. 참고로 `Ubuntu Desktop`은 부팅 시 자동으로 X 윈도우가 시작되므로 런레벨 5번으로 지정되며, Ubuntu Server는 텍스트 모드로 실행되므로 런레벨이 3번으로 지정된다.

### 자동 완성과 히스토리
자동 완성은 파일 이름의 일부만 입력하고 `Tab`키를 눌러 나머지 파일 이름 또는 폴더 이름을 자동으로 완성하는 기능이다.

도스 키<sup>Dos Key</sup>란 `↑`/`↓`키를 통해 이전에 입력한 명령이 다시 나타나게 하는 것을 말한다.

### 에디터 사용
Windows의 메모장처럼 X 윈도우에서 제공하는 편리한 에디터로는 `gedit`이 있다. 터미널에서 `gedit 파일이름` 명령을 입력하면 해당 파일을 편집할 수 있다.

이보다 더 전통적인 것으로 `vi` 에디터가 있으며 모든 유닉스/리눅스 시스템에 기본적으로 포함되어 있다.

### 도움말 사용법
리눅스에는 엄청난 양의 명령어가 있다. 이를 모두 외울 수 없으니 man 명령을 통해 도움받을 수 있다. 사용 방법은 간단히 `man 명령어`를 사용하면 된다.

### 마운트와 CD/DVD, USB 활용
리눅스에서 하드디스크의 파티션, CD/DVD, USB 메모리 등을 사용하려면 지정한 위치에 연결해 줘야 한다. 이렇게 물리적인 장치를 특정한 위치(대개 폴더)에 연결시키는 과정을 '마운트'라고 한다.

```bash
mount     # 마운트된 장치 확인
umount    # 마운트된 장치 해제
```

### 리눅스에서 ISO 파일 생성
리눅스에는 명령을 통해 ISO 파일을 생성할 수 있다. 이를 위해서는 우선 패키지를 설치해야 한다.

```bash
apt -y install genisoimage  # 패키지 설치
```

ISO 파일을 생성은 `genisoimage -r -J -o 생성될ISO파일이름 포함될파일또는디렉토리` 형식으로 입력하면 된다.

```bash
genisoimage -r -J -o boot.iso /boot   # /boot 디렉토리의 모든 파일을 boot.iso파일로 만들어라
```

## 사용자와 그룹 관리
### 사용자와 그룹의 개념
리눅스는 **다중 사용자 시스템<sup>multi-user system</sup>**이다. 즉, 1대의 리눅스에 사용자 여러 명이 동시에 접속해서 사용할 수 있는 시스템이다.

리눅스를 처음 설치하면 기본적으로 root라는 이름을 가진 **슈퍼 유저<sup>super user</sup>**가 있다. root 사용자에게는 시스템의 모든 작업을 실행할 수 있는 권한이 있다. 또한 시스템에 접속할 수 있는 사용자를 생성할 수 있는 권한도 있다.

추가로 모든 사용자는 혼자서 존재하는 것이 아닌 하나 이상의 그룹에 소속되어 있어야 한다.

> 회사의 직원이 부서에 소속되는 것과 유사하다.
{: .prompt-info}

```bash
vi /etc/passwd
```

명령을 통해 파일을 열면 사용자 목록이 나오게 된다. ubuntu 사용자를 이용해 구성을 분석하면 다음과 같다. 

> ubuntu:x:1000:1000:ubuntu:/home/ubuntu:/bin/bash<br>
사용자 이름:암호:사용자 id:사용자가 소속된 그룹 id:추가 정보:홈 디렉토리:기본 셸

**[사용자 이름]**은 ubuntu이며, **[암호]**가 x로 표시되는 것은 `/etc/shadow` 파일에 비밀번호가 저장되어 있다는 뜻이다. 

**[사용자의 id]**는 1000번이며 **[사용자가 속한 그룹의 id]**는 1000번이다.

**[추가 정보]**는 '전체 이름, 사무실 호수, 직장 전화번호, 집 전화번호, 기타'로 나타내는데 모두 생략 가능하다.

**[홈 디렉토리]**는 `/home/ubuntu`이고, 로그인 시 제공되는 **[셸]**은 `/bin/bash`이다.

다음으로 /etc/group 파일을 확인하자.

```bash
vi /etc/group
```

> ubuntu:x:1000:<br>
그룹 이름:비밀번호:그룹id:그룹에 속한 사용자 이름

**[그룹 이름]**은 ubuntu이다. 즉, ubuntu 사용자는 ubuntu 그룹에 속한 것이다.

**[비밀번호]**는 사용자와 마찬가지로 x로 표시된다.

**[그룹id]**는 1000번이다. 사용자 정보와 마찬가지로 ubuntu 사용자가 ubuntu 그룹에 속한 것을 의미한다.

**[그룹에 속한 사용자 이름]**은 참조로 사용된다. 즉, 해당 부분이 비어있더라도 그룹에 소속된 사용자가 반드시 없다는 뜻은 아니다.

### 사용자와 그룹 관련 명령어
- **`adduser`**
  - 새로운 사용자를 추가한다.
  - 명령을 실행하면 `/etc/passwd`, `/etc/shadow`, `/etc/group` 파일에 새로운 행이 추가된다.

```bash
adduser newuser1                    # newuser1이라는 신규 사용자 생성
adduser --uid 1111 newuser2         # newuser2 사용자를 생성하면서 사용자 id를 1111로 지정
adduser --gid 1000 newuser3         # newuser3 사용자를 생성하면서 그룹 id가 1000인 그룹에 newuser3을 포함시킴
adduser --home /newhome newuser4    # newuser4 사용자를 생성하면서 홈 디렉토리를 /newhome으로 지정
adduser --shell /bin/csh newuser5   # newuser5 사용자를 생성하면서 기본 셸을 /bin/csh로 지정
``` 

> 신규 사용자를 추가할 때 암호와 추가 정보(전체 이름, 사무실 호수 등)를 입력하게 한다.
{: .prompt-tip}

- **`passwd`**
  - 사용자의 비밀번호를 변경한다.
  - 일반 사용자는 `passwd` 명령으로 자신의 비밀번호만 지정/변경할 수 있다.
  - root 사용자는 `passwd 사용자이름`으로 모든 사요자의 비밀번호를 지정/변경할 수 있다.

```bash
passwd newuser1
```

- **`usermod`**
  - 사용자의 속성을 변경한다.

```bash
usermod --shell /bin/csh newuser1     # newuser1 사용자의 기본 셸을 /bin/csh로 변경
usermode --groups ubuntu newuser1     # newuser1의 사용자 보조 그룹에 ubuntu 그룹 추가
```

- **`userdel`**
  - 사용자를 삭제한다.

```bash
userdel newuser2      # newuser2 사용자 삭제 (단, 홈 디렉토리는 삭제되지 않음)
userdel -r newuser3   # newuser3 사용자를 삭제하면서 홈 디렉토리까지 삭제
```

- **`chage`**
  - ***Change Age***의 약자로 사용자의 암호를 주기적으로 변경하도록 설정한다.

```bash
chage -l newuser1             # newuser1 사용자에 설정된 사항 확인
chage -m 2 newuser1           # newuser1 사용자에 설정한 암호를 사용해야 하는 최소 일자 (최소 2일은 사용해야 함)
chage -M 30 newuser1          # newuser1 사용자에 설정한 암호를 변경할 수 있는 최대 일자 (변경 후 최대 30일까지 사용 가능)
chage -E 2030/12/12 newuser1  # newuser1 사용자에 설정한 암호가 만료되는 날짜 (2030년 12월 12일까지만 사용 가능)
chage -W 10 newuser1          # newuser1 사용자에 설정한 암호가 만료되기 전에 경고하는 기간 (지정하지 않을 경우 기본값은 7)
```

- **`groups`**
  - 사용자가 소속된 그룹을 보여준다.

```bash
groups            # 현재 사용자가 소속된 그룹을 보여줌
groups newuser1   # newuser1 사용자가 소속된 그룹을 보여줌
```

- **`groupadd`**
  - 새로운 그룹을 생성한다.

```bash
groupadd newgroup1              # newgroup1이라는 그룹 생성
groupadd --gid 2222 newgroup2   # newgroup2 그룹을 생성하면서 그룹 id를 2222로 지정
```

- **`groupmod`**
  - 그룹의 속성을 변경한다.

```bash
groupmod --new-name mygroup1 newgroup1  # newgroup1 그룹의 이름을 mygroup1로 변경
```

- **`groupdel`**
  - 그룹을 삭제한다.

```bash
groupdel newgroup2  # newgroup2 그룹 삭제 (단, 해당 그룹을 주요 그룹으로 지정한 사용자가 없어야 함)
```

- **`gpasswd`**
  - 그룹의 비밀번호를 설정하거나 그룹 관리를 수행한다.

```bash
gpasswd mygroup1                # mygroup1 그룹의 암호 지정
gpasswd -A newuser1 mygroup1    # newuser1 사용자를 mygroup1 그룹의 관리자로 지정
gpasswd -a newuser4 mygroup1    # newuser4 사용자를 mygroup1 그룹의 사용자로 추가
gpasswd -d newuser4 mygroup1    # newuser4 사용자를 mygroup1 그룹의 사용자에서 제거
```

> 리눅스의 명령어에는 각각 많은 옵션이 있다. 명령어의 옵션에 대해 궁금하다면 `명령어 --help` 명령을 실행하면 정보를 알 수 있다.
{: .prompt-tip}

## 파일 속성
리눅스에서 파일을 관리하기 위해서는 소유권과 허가권, 링크 등의 속성을 알아야 한다.

### 파일과 디렉토리의 소유권과 허가권
리눅스는 각각의 파일과 디렉토리마다 소유권과 허가권이라는 속성이 있다.

```bash
touch test.txt
```

위 명령으로 빈 파일을 만들고

```bash
ls -l test.txt
```

위 명령을 실행하면 파일 속성을 확인할 수 있다.

![](/assets/img/post/Textbook/Ubuntu%20Linux/Ch04/file_attribute.png)

- 파일의 유형
  - 파일이 어떤 종류인지 나타낸다.
    - 디렉토리: d
    - 일반 파일: -
    - 블록 디바이스: b
    - 문자 디바이스: c
    - 링크: l

> 블록 디바이스<sup>Block Device</sup>는 하드디스크나 CD/DVD 등의 저장장치를 의미하며, 문자 디바이스<sup>Character Device</sup>는 마우스, 키보드 등의 입출력 장치를 의미한다. 마지막으로 링크<sup>Link</sup>는 Windows의 바로가기 아이콘과 유사한 개념으로 연결된 파일을 의미한다.
{: .prompt-tip}

- 파일 허가권
  - 파일의 읽기<sup>Read</sup>, 쓰기<sup>Write</sup>, 실행<sup>Execute</sup> 권한을 나타낸다.
  - rw-, r--, r-x처럼 3개씩 끊어서 확인한다.
    - rw-: 소유자<sup>user</sup>의 파일 접근 권한 (읽기, 쓰기 가능)
    - r--: 그룹<sup>group</sup>의 파일 접근 권한 (읽기 가능)
    - r-x: 그 외 사용자<sup>other</sup>의 파일 접근 권한 (읽기, 실행 가능)

파일 허가권은 숫자로도 표현할 수 있다.

<!-- |<center>소유자(User)</center>|<center>그룹(Group)</center>|<center>그 외 사용자(Other)</center>|
|---|---|---|
|r|w|-|r|-|-|r|-|1|
|4|2|0|4|0|0|4|0|1|
|6|4|5| -->
<table>
  <thead>
    <tr>
      <th colspan="3" style="text-align: center;">소유자(User)</th>
      <th colspan="3" style="text-align: center;">그룹(Group)</th>
      <th colspan="3" style="text-align: center;">그 외 사용자(Other)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>r</td>
      <td>w</td>
      <td>-</td>
      <td>r</td>
      <td>-</td>
      <td>-</td>
      <td>r</td>
      <td>-</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>0</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>4</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td colspan="3" style="text-align: center;">6</td>
      <td colspan="3" style="text-align: center;">4</td>
      <td colspan="3" style="text-align: center;">5</td>
    </tr>
  </tbody>
</table>

파일 허가권을 변경하는 명령어로 `chmod`가 있다. 예를 들어 `chmod 777 test.txt` 명령을 실행하면 해당 파일은 모든 사용자가 읽고, 쓰고, 실행할 수 있다.

> 이 명령어는 root 사용자나 해당 파일의 소유자만이 가능하다.
{: .prompt-tip}

또한 `chmod` 명령을 상대 모드<sup>symbolic method</sup>로도 사용할 수 있다. 만약 `chmod u+x 파일이름` 명령을 실행한다면 소유자에게 실행 권한을 **허가한다(+)**는 의미이며, `chmod g-wx 파일이름` 명령을 실행한다면 그룹에게 쓰기와 실행 권한을 **제거한다(-)**는 의미이다. 또 `chmod o+rwx 파일이름`을 실행한다면 그 외 사용자에게 읽기/쓰기/실행 권한을 허가한다는 뜻이 된다.

- 파일 소유권
  - 파일을 소유한 사용자와 그룹을 의미한다.
  - 위 이미지의 파일의 소유자는 `oracle`이며, 그룹은 `dba`이다.

파일의 소유권은 `chown` 명령으로 변경 가능하다. 사용법은 `chown 새로운사용자이름(:새로운그룹이름) 파일이름` 형태로 사용하면 된다.

만약 `chown ubuntu test.txt` 명령을 실행하면 test.txt 파일의 소유자를 ubuntu 사용자로 변경하는 것을 의미하며, `chown ubuntu:ubuntu test.txt` 명령은 파일의 그룹도 ubuntu 그룹으로 변경하라는 의미이다.

또한 `chgrp ubuntu test.txt` 명령은 그룹만 ubuntu 그룹으로 변경하라는 의미이다.

### 링크
파일의 링크는 하드 링크<sup>Hard Link</sup>와 심볼릭 링크<sup>Symbolic Link 또는 Soft Link</sup>가 있다.

원본 파일이 `inode1`을 사용할 때 하드 링크를 생성하면 같은 `inode1`을 사용하는 링크 파일이 생성되며, 소프트 링크를 생성하면 새로운 `inode2`와 링크 파일이 생성된다.

> **inode**는 유닉스/리눅스의 파일 시스템에서 사용하는 자료구조이다. 여기에는 소유권, 허가권, 파일 종류 등의 정보와 실제 주소를 포함한다. 모든 파일이나 디렉토리는 각자 1개씩의 inode가 있다.
{: .prompt-tip}

하드 링크를 생성하려면 `ln 링크대상파일이름 링크파일이름` 명령을 실행하면 되고, 소프트 링크를 생성하려면 `ln -s 링크대상파일이름 링크파일이름` 명령을 실행하면 된다.

참고로 Windows의 바로 가기 아이콘이 심볼릭 링크에 해당된다.