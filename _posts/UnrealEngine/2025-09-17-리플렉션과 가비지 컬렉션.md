---
title: "[UnrealEngine] 리플렉션과 가비지 컬렉션"
description: 언리얼 엔진을 통해 살펴보는 리플렉션과 가비지 컬렉션
date: 2025-09-17 00:00:00 +09:00
categories: [GameDev, UnrealEngine]
tags:
  [
    UnrealEngine,
    C++,
  ]
---

## 개요
**UObject**는 언리얼 엔진에서 제공하는 다양한 기능들을 사용할 수 있는 최상위 클래스이다. 여기서 말하는 다양한 기능들에는 리플렉션과 가비지 컬렉션은 물론 에디터와의 연동, 네트워크 복제 등 다양하다. 이번 포스팅에서는 이러한 여러 기능들 중 **리플렉션**과 **가비지 컬렉션**에 대해 정리하고자 한다.

## 리플렉션
**리플렉션(Reflection)**이란 런타임 중에 자기 자신의 구조를 들여다보고 이를 조작할 수 있게 하는 기능이다. 핵심 기능을 정리하면 다음과 같다.

- **타입 정보 확인 (Introspection)**
  - 객체가 어떤 클래스인지
  - 클래스의 멤버(필드, 메서드)가 무엇인지
  - 메서드의 파라미터와 반환 타입이 무엇인지
- **동적 객체 생성 및 메소드 호출 (Dynamic Instantiation & Invocation)**
  - 클래스 이름을 문자열로 전달해서 해당 클래스의 객체를 동적으로 생성
  - 메서드도 마찬가지
- **멤버 변수 접근 및 수정 (Member Access & Modification)**
  - 변수 이름을 문자열로 접근해 읽거나 수정 가능 (private으로 선언된 것도 가능하지만 권장되진 않음)

하지만 C++은 언어 차원에서 리플렉션을 지원하지 않는다. 그렇기에 언리얼 엔진에서는 **자체적인 리플렉션**을 구축했다.

```c++
#include "MyObject.generated.h"

// UObject류 클래스 정의
UCLASS()                            // 리플렉션되는 클래스임을 알림
class UMyObject : public UObject
{
  GENERATED_BODY()                  // 언리얼 헤더 툴(Unreal Header Tool, UHT)이 자동 생성한 코드가 삽입될 위치임을 알리는 마커

  UFUNCTION()                       // 리플렉션되는 멤버 함수임을 알림
  void MyFunc();

  UPROPERTY()                       // 리플렉션되는 멤버 변수임을 알림
  int32 MyData;
};

// 열거형 정의
UENUM()                             // 리플렉션되는 열거형임을 알림
enum class EMyEnum
{

};

// 구조체 정의 
USTRUCT()                           // 리플렉션되는 구조체임을 알림
struct FMyStruct
{
  GENERATED_BODY()

  UPROPERTY()
  int32 MyData;

  // 구조체의 멤버 함수는 일반적으로 UFUNCTION으로 지정하지 않음
};
```

위 코드와 주석을 이해하기 위해서는 우선 언리얼의 빌드 과정을 살펴봐야 한다. 빌드가 실행되면 먼저 **언리얼 헤더 툴(Unreal Header Tool, UHT)**이 실행된다. 이 툴은 사용자가 작성한 소스 코드를 쭉 훑어가며 `UCLASS()`나 `USTRUCT()`가 붙은 클래스를 찾아 리플렉션 정보를 수집한다. 그 후 수집된 정보를 바탕으로 `generated.h`라는 C++ 코드를 자동으로 생성하게 되며, 이 과정이 종료되면 C++ 컴파일러가 실행된다.

> generated.h 파일과 함께 geneted.cpp 파일도 자동 생성된다. 두 파일은 Intermediate 폴더 내에 생성되며, 해당 영역은 UHT에 의해 숨겨진다.
{: .prompt-info}

이렇게 되면 해당 클래스는 리플렉션을 통해 가비지 컬렉션, 에디터와의 연동 등 다양한 기능들을 사용할 수 있게 된다.

## 가비지 컬렉션
C++에서는 런타임 중에 객체를 생성하기 위해서 `new`를 사용하고, 사용이 끝난 객체를 `delete`로 해제시켜야 한다. 이는 메모리 누수나 댕글링 포인터 등의 문제를 방지하기 위해 반드시 지켜야 하지만, 사람은 누구나 실수한다. 그렇기에 언리얼에서는 **가비지 컬렉션(Garbage Collection, GC)**을 이용해 메모리를 자동으로 관리한다.

<!-- ### 참조 카운터 방식
C++에서는 스마트 포인터를 통해 참조 카운트 방식으로 메모리를 관리할 수 있다. 특히 참조 포인터 객체(shared_ptr)를 사용해 객체의 참조 카운팅을 늘리고, 만약 카운트가 0이 됐을 때 자동으로 메모리를 해제한다. 하지만 shared_ptr은 순환참조 구조가 되면 카운트가 0이 되지 못해 메모리 누수가 발생될 수 있다. 이때 weak_ptr을 사용하게 되면 문제를 해결할 수 있다. -->

<!-- ### Mark-Sweep 방식 -->
언리얼 엔진에서의 가비지 컬렉션은 **Mark-Sweep 방식**으로 동작한다. 이는 도달 가능한 객체들을 순회하며 사용 중인 객체와 그렇지 않은 객체를 구분해 표시한 후 미사용 객체의 메모리를 해제하게 된다. 이때 한 사이클을 돌며 필요하지 않은 객체일지라도 바로 해제하지 않고, **필요 시 한번에 정리**한다.

여기서 중요한 점은 `UPROPERTY`를 사용한 UObject 포인터가 가리키는 객체일 때, GC는 이를 사용 중인 객체로 판단한다는 점이다. 즉, 원시 포인터가 가리키는 객체는 GC 입장에서 사용되지 않는 객체로 판단해 메모리에서 해제되어 댕글링 포인터가 될 수 있다.

## 참고
{% linkpreview "https://youtu.be/VpEe9DbcZIs?si=Xnb-M1cYKGN5JASh" %}