---
title: "[UnrealEngine][DareDevil] 개발 일지 - 009"
description: 2025년 12월 16일 개발 일지
date: 2025-12-16 00:00:00 +09:00
categories: [GameDev, UnrealEngine, DevNote]
tags:
  [
    UnrealEngine,
    C++,
  ]
---

![](/assets/img/post/Daredevil/Daredevil.png){: width="600" height="400" }

## 💻 개요

- Freeflow 전투 시스템 구현 Part2

## 🤔 작업 내용

공격 애니메이션마다 이동 거리, 재생 속도 등이 제각각이며 공격을 구분하기 위한 데이터가 필요함을 느꼈다. 그렇기에 이를 테이블로 정리하여 관리하고자 했다.

```c++
UENUM(BlueprintType)
enum class EMeleeDistance : uint8
{
    None = 0,
    PointBlank,
    Strike,
    Lunge,
};

UENUM(BlueprintType)
enum class EMeleeDirection : uint8
{
    None = 0,
    Front,
    Left,
    Right,
    Back,
};

UENUM(BlueprintType)
enum class EMeleeSide : uint8
{
    None = 0,
    Left,
    Right,
    Both,
};
```

`MeleeDistance`는 적까지의 거리에 따라 재생시킬 애니메이션을 구분하기 위해 만든 `enum` 타입이다. 가까운 적일수록 루트 모션이 짧은 애니메이션이 재생되고, 멀수록 긴 애니메이션이 재생된다. 

다음 `MeleeDirection`은 적 방향에 따라 재생시킬 애니메이션을 구분하기 위해 만든 `enum` 타입이다. 실제로 소유한 애니메이션 시퀀스들은 방향에 따른 공격이 구분되어 있어 이를 활용하고자 했다. 

마지막으로 `MeleeSide`는 공격하는 대상의 공격 방향을 나타낸다. 왼쪽 공격과 오른쪽 공격을 번갈아가며 재생시킬 목적으로 만들었는데, 그렇지 않으면 어색하게 보이기 때문이다.

```c++
USTRUCT(BlueprintType)
struct FMeleeData : public FTableRowBase
{
    GENERATED_BODY()

public:
    // 몽타주의 이동거리에 따른 구분용
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    EMeleeDistance MeleeDistance = EMeleeDistance::None;

    // 공격 방향
    UPROPERTY(EditDefaultsOnly, BlueprintType)
    EMeleeDirection MeleeDirection = EMeleeDirection::None;

    // 공격 몽타주 좌우 구분용
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    EMeleeSide MeleeSide = EMeleeSide::None;
	
    // 재생할 몽타주
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    TObjectPtr<UAnimMontage> AttackMontage = nullptr;

    // 몽타주 재생 배속
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    float PlayRate = 1.f;

    // 적과 떨어질 거리
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
    float DistanceOffset = 0.f;
};
```

그런 다음 `FTableRowBase`를 상속받아 데이터 테이블로 만들 수 있도록 했다. 구조체 멤버에는 만들었던 `enum`을 포함해 몽타주의 재생 속도, 모션 워핑에 대한 오프셋을 추가했다.

![](/assets/img/post/Daredevil/Freeflow/data_table_melee.png)
_행 이름은 몽타주 이름을 사용했다_

이 테이블을 바탕으로 공격 애니메이션을 지정해줘야 한다. 간단히 랜덤하게 애니메이션을 재생하는 방법도 있지만 이럴 경우 특정 애니메이션만을 반복할 가능성이 있어 `Shuffle` 로직을 사용하기로 했다.

```c++
USTRUCT()
struct FMeleeShuffleBag
{
	GENERATED_BODY()

public:
	// 원본 데이터 (리필용)
	TArray<FMeleeData*> MasterList;

	// 현재 사용 중인 데이터 (소진되면 리필)
	TArray<FMeleeData*> CurrentBag;
};

// ...

TMap<uint32, FMeleeShuffleBag> MeleeShuffleBagMap;
```

우선 상황에 따라 공격을 저장하기 위한 구조체를 만들었다. 그리고 이를 `Value`로 가지는 `TMap`을 만들었다.

```c++
CachedMeleeDataTable->GetAllRows<FMeleeData>(TEXT("MeleeDataTable"), LoadedMeleeRows);

for (FMeleeData* MeleeData : LoadedMeleeRows)
{
    if (MeleeData == nullptr || MeleeData->AttackMontage == nullptr)
        continue;
    
    uint32 Key = GetMeleeShuffleBagKey(MeleeData->MeleeDistance, MeleeData->MeleeDirection);
    FMeleeShuffleBag& Bag = MeleeShuffleBagMap.FindOrAdd(Key);

    Bag.MasterList.Add(MeleeData);
}
```

그리고 `BeginPlay`에서 거리와 방향을 Key로 지정해 데이터를 저장했다. 

> Key는 비트 연산을 통해 겹치지 않도록 했다.
{: .prompt-info}

```c++
TArray<FMeleeData*> MeleeCandidates;
InitializeCandidates(MeleeCandidates, SelectedBag);

FMeleeData* PickedData = nullptr;
if (MeleeCandidates.Num() > 0)
{
    uint32 RandomIndex = FMath::RandRange(0, MeleeCandidates.Num() - 1);
    PickedData = MeleeCandidates[RandomIndex];
}
else
    PickedData = SelectedBag->CurrentBag[0];

if (PickedData != nullptr)
{
    SelectedBag->CurrentBag.RemoveSingle(PickedData);	
    LastSelectedMeleeData = PickedData;
}

return PickedData;
```

그런 다음 공격 키를 눌렀을 때 상황에 맞는 Key를 구해 후보군을 정리한다. 그리고 이 중 아무 데이터를 선택해 반환해주면 된다. 중요한 점은 선택된 데이터는 후보군에서 지워준다는 것이다. 그렇지 않으면 다음 공격 시 또 같은 공격이 나갈 수 있기 때문이다.

최종 결과는 다음과 같다.

{% include embed/youtube.html id='XmAoEXIi9Kk' %}

## 💡 새롭게 배운 점

- Shuffle 알고리즘을 통한 랜덤 뽑기

## 🚀 다음 목표

- 공격 데이터를 이용한 피격 시스템