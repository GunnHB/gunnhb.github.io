---
title: "[C++] 가상함수"
date: 2025-08-08 10:37:00 +09:00
categories: [Programming, C++]
tags:
  [
    Programming,
    C++,
  ]
---

## 개요
개발을 진행하다보면 관련된 여러 객체를 하나의 인터페이스로 관리해야 하는 상황을 마주하게 된다. 예를 들어, 게임 내 전사, 궁수, 마법사 캐릭터가 있을 때 똑같이 '공격'이라는 공통된 행위를 하지만, 각자만의 방식으로 이를 수행해야 한다. 만약 모든 캐릭터를 `Character` 타입의 포인터 배열로 관리하면서, 각 캐릭터의 실제 클래스에 맞는 `Attack` 함수를 호출하고 싶다면 어떻게 해야할까?

이러한 문제를 해결하는 핵심 메커니즘이 바로 **가상 함수(Virtual Function)**이다. 이번 포스팅에서는 C++의 중요한 기능 중 하나인 가상 함수에 대해 정리하고자 한다.

## 가상함수를 사용하는 이유
우선 가상 함수란 상속 관계에서 부모 클래스의 함수 중 자식 클래스가 **재정의할 것으로 기대하고 정의한 함수**로, `virtual` 키워드를 붙여 만들 수 있다. 

그럼 가상함수를 사용하는 이유가 뭘까? 간단히 말하자면 **코드가 유연해져 개발이 편해진다.** 앞서 언급한 예시처럼 상속 관계에서 부모 클래스의 포인터가 자식 클래스의 객체를 참조할 때, 가상 함수가 없다면 사용자가 직접 각 객체의 타입을 확인해서 올바른 함수를 호출해줘야 한다.

다음과 같은 클래스가 있다고 가정하자.

```c++
class Animal
{
public:
	void Speak() 
	{
		std::cout << "Speak By Animal" << std::endl;
	}
};

class Dog : public Animal
{
public:
	void Speak()
	{
		std::cout << "Speak By Dog" << std::endl;
	}
};
```

코드를 살펴보면, `Animal` 클래스를 상속받는 `Dog` 클래스가 있고, 각 클래스 내부에는 `Speak` 함수가 구현되어 있다. 이를 다음과 같이 실행하고자 한다.

```c++
int main()
{
	Animal* pAnimal = new Dog();

	pAnimal->Speak();

	delete pAnimal;

	return 0;
}
```

```
Speak By Animal
```

실행 결과를 예상할 때, `pAnimal` 포인터는 `Dog` 객체를 가리키고 있으니 `Speak By Dog`가 출력될 것 같지만 그렇지 않다. 왜냐하면 컴파일러는 기본적으로 **포인터 타입**을 기준으로 어떤 함수를 호출할지 **컴파일 시점**에 결정하기 때문이다. 

결국 `pAnimal`의 타입은 `Animal*`이므로, 컴파일러는 `Animal` 클래스의 `Speak()`를 호출하도록 결정한 것인데, 이를 **정적 바인딩(Static Binding)**이라고 한다.

### 가상함수로 문제 해결하기
그럼 포인터가 실제로 가리키는 객체의 함수가 호출되도록 수정해보자. 방법은 간단하다. 부모 클래스의 함수 선언 앞에 `virtual` 키워드만 붙여주면 된다.

```c++
class Animal
{
public:
	virtual void Speak()
	{
		std::cout << "Speak By Animal" << std::endl;
	}
};

class Dog : public Animal
{
public:
	void Speak() override
	{
		std::cout << "Speak By Dog" << std::endl;
	}
};
```

```
Speak By Dog
```

그 후 다시 실행 결과를 확인해보면 의도했던 `Speak By Dog`가 출력되는 것을 확인할 수 있다. 가상 함수를 사용하면 컴파일러는 **런타임 시점**에 포인터가 가리키는 **실제 객체 타입**을 확인해 그에 맞는 함수를 호출하는데, 이를 **동적 바인딩(Dynamic Binding)**이라고 한다.

> `override` 키워드는 자식 클래스의 함수가 부모의 가상 함수를 재정의한다는 것을 명시적으로 나타낸다. 만약 부모 클래스에 해당 가상 함수가 없다면, 컴파일 에러를 발생시켜 실수를 방지할 수 있다.
{: .prompt-tip }

## 가상 소멸자
`virtual` 키워드를 통해 타입에 맞는 `Speak()`가 호출되는 것을 확인했다. 그런데 코드를 다시 보니 `delete pAnimal;`이 찜찜하다. 혹시 `Speak()` 함수처럼, **소멸자도 `Animal`의 것만 호출되는 게 아닐까?**

확인을 위해 Animal과 Dog 클래스에 각각 소멸자를 추가한 후 코드를 실행하자.

```c++
class Animal
{
public:
	~Animal()
	{
		std::cout << "Destructor By Animal" << std::endl;
	}

	virtual void Speak() 
	{
		std::cout << "Speak By Animal" << std::endl;
	}
};

class Dog : public Animal
{
public:
	~Dog()
	{
		std::cout << "Destructor By Dog" << std::endl;
	}

	void Speak() override
	{
		std::cout << "Speak By Dog" << std::endl;
	}
};
```

```
Speak By Dog
Destructor By Animal
```

결과를 확인해보면, 우려했던 대로 `Animal`의 소멸자가 호출되는 것을 알 수 있다. 만약 `Dog` 클래스 내에 동적으로 메모리를 할당했다면, 이 메모리를 해제하지 못해 **메모리 누수(Memory Leak)**가 발생했을 것이다.

### 가상 소멸자로 문제 해결하기
이 문제 역시 부모 클래스의 소멸자 앞에 `virtual` 키워드를 붙여주기만 하면 간단히 해결된다.

```c++
class Animal
{
public:
	virtual ~Animal()
	{
		std::cout << "Destructor By Animal" << std::endl;
	}

	virtual void Speak() 
	{
		std::cout << "Speak By Animal" << std::endl;
	}
};
```

```
Speak By Dog
Destructor By Dog
Destructor By Animal
```

결과를 확인해보면 인상적인 부분이 있는데, 바로 **자식의 소멸자가 호출된 뒤 부모의 소멸자가 호출**된다는 것이다.

이 호출 순서는 객체를 안전하게 소멸시키기 위한 C++의 중요한 규칙인데, 자식 클래스는 부모 클래스의 멤버나 기능을 사용하고 있을 가능성이 높기 때문이다. 만약 부모의 소멸자가 먼저 호출되어 부모의 자원이 사라진다면, 아직 소멸되지 않은 자식 클래스는 이미 사라진 자원을 참조하려다 오류를 발생시킬 수 있다.

따라서 가상 소멸자는 단순히 타입에 맞는 소멸자를 찾아주는 것을 넘어, **안전한 소멸 순서가 시작되도록 보장**해주는 매우 중요한 역할을 한다.

## 가상 함수 테이블
그럼 어떻게 `virtual` 키워드 하나 붙였다고 동적 바인딩을 수행할 수 있는걸까? 이는 **가상 함수 테이블(Virtual Function Table, vtable)** 덕분이다.

가상 함수 테이블은 **가상 함수들의 주소를 모아놓은 배열**이다. 이는 컴파일러에 의해 가상 함수를 하나라도 가진 클래스를 대상으로 만들어지며, 클래스당 하나씩 생성되고 메모리의 **데이터 영역**에 저장된다.

하지만 이걸로는 부족하다. 클래스에 테이블이 있다는 건 알겠는데, 객체는 어떻게 그 테이블을 찾아갈 수 있을까?

이때 등장하는 것이 **가상 함수 포인터(Virtual Pointer, vptr)**이다. 컴파일러는 가상 함수를 가진 클래스의 객체가 생성될 때, 그 객체 안에 `vptr`이라는 숨겨진 포인터 멤버를 추가한다. 이 `vptr`은 자기 클래스의 `vtable`을 가리키는 역할을 한다.

이 과정을 `Animal`과 `Dog` 예시에 적용해보면 다음과 같다.

- `Animal` 클래스는 `~Animal()`과 `Speak()`의 주소가 담긴 `Animal`의 `vtable`을 가진다.
- `Dog` 클래스는 재정의된 `~Dog()`와 `Speak()`의 주소가 담긴 `Dog`의 `vtable`을 가진다.
- `Animal* pAnimal = new Dog();` 가 실행되면, 생성된 `Dog` 객체 안의 `vptr`은 **`Dog`의 `vtable`을 가리키게 된다.**

여기서 `pAnimal->Speak();`가 실행되면 다음과 같은 과정을 거친다.

- 프로그램은 `pAnimal`이 가리키는 `Dog` 객체로 찾아간다.
- 객체 안에 숨겨진 `vptr`을 따라 `Dog`의 `vtable`로 이동한다.
- `Dog`의 `vtable`에서 `Speak()` 함수에 해당하는 주소를 찾아 이를 호출한다.

이처럼 `vtable`과 `vptr`을 이용한 간접적인 호출 방식으로 인해, 런타임에 실제 객체에 맞는 함수를 찾아가는 동적 바인딩이 가능해지는 것이다.

> 다만, 가상 함수를 사용할 경우 약간의 비용이 발생한다.
> - 모든 객체는 `vptr`을 위한 **추가적인 메모리를 차지**한다.
> - 함수를 호출할 때 `vtable`을 거치기 때문에 일반 함수 호출보다 **약간의 성능 오버헤드**가 발생한다.
{: .prompt-warning}