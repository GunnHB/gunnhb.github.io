---
title: "[C++ 기초] 생성자와 소멸자"
description: C++의 다양한 생성자와 소멸자
date: 2025-12-20 00:00:00 +09:00
categories: [Programming, C++]
tags:
  [
    Programming,
    C++,
  ]
---

> 공부한 내용을 정리한 글입니다.

## 생성자
**생성자(Constructor)**는 클래스의 인스턴스를 생성할 때 **가장 먼저 호출**되는 특별한 함수이다. 주로 멤버의 초기화하거나 필요한 리소스를 할당하는 역할을 한다.

특징
- 클래스와 똑같은 이름을 가진다.
- 반환 타입이 없다.
- 객체가 생성될 때 딱 한 번 호출된다.

사실 멤버의 초기화는 사용자 정의 함수를 통해서도 가능하다. 다음과 같은 클래스가 있다고 가정하자.

```c++
class Person
{
	int Age;

public:
	void SetAge(int InAge)
	{
		Age = InAge;
	}

	void Print()
	{
		std::cout << "Age: " << Age << std::endl;
	}
};
```

클래스의 멤버 변수인 `Age`는 멤버 함수인 `SetAge`를 통해 초기화된다. 그리고 `Print` 함수를 호출하면 `Age`의 값이 나오게 된다.

```c++
int main()
{
	Person person;

	person.SetAge(10);
	person.Print();

	return 0;
}
```

```text
Age: 10
```

하지만 `SetAge` 함수를 만들지 않거나 호출하지 않으면 `Age`에는 쓰레기 값이 들어있게 된다.

```c++
int main()
{
	Person person;

	person.Print();

	return 0;
}
```

```text
Age: -858993460
```

물론 `Setter` 함수를 만들고 호출하기만 한다면 아무 문제 없다. 하지만 사람은 누구나 실수하고 클래스를 만들 때마다 해당 함수를 만드는 것도 번거롭다. 이를 위해 **생성자를 사용**하는 것이다.

위 코드에 멤버 변수를 초기화하는 생성자를 추가하면 다음과 같다.

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

private:
	int Age;

public:
	void Print()
	{
		std::cout << "Age: " << Age << std::endl;
	}
};
```

이렇게 하면 객체를 생성하면서 멤버를 바로 초기화할 수 있게 된다.

```c++
int main()
{
	Person person(30);
	person.Print();

	return 0;
}
```

```text
Age: 30
```

### 디폴트 생성자
위에서 생성자는 객체를 생성할 때 가장 먼저 호출되는 함수라고 했다. 하지만 클래스에 생성자를 만들어주지 않아도 생성자가 호출되는데, 이는 컴파일러가 자동으로 추가해주는 `디폴트 생성자(Default Constructor)`가 호출되기 때문이다.

```c++
class Person
{
private:
	int Age;
};

int main()
{
	Person person;  // 컴파일러가 만들어준 디폴트 생성자 호출
}
```

> `Person person()`처럼 객체를 생성해서는 안된다. 컴파일러는 이를 `Person` 타입의 `person` 함수를 선언하는 것으로 인식한다.
{: .prompt-warning}

디폴트 생성자는 매개 변수가 없는 생성자를 말한다. 이는 사용자가 직접 추가할 수도 있다.

```c++
class Person
{
public:
  Person()
  {
    // 사용자가 추가한 디폴트 생성자
  }

private:
	int Age;
};
```

언급한 것처럼 **생성자가 없을 경우** 컴파일러가 자동으로 추가한다고 했다. 만약 사용자가 어떠한 생성자를 추가했다면 컴파일러는 **디폴트 생성자를 추가하지 않는다.**

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

private:
	int Age;
};

int main()
{
	Person person;  // 디폴트 생성자가 생성되지 않아 컴파일 에러 발생!

	return 0;
}
```

### 생성자 오버로딩
생성자는 함수이다. 즉 생성자 역시 **오버로딩(overloading)**이 가능하다.

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

	Person(int InAge, float InHeight)
	{
		Age = InAge;
		Height = InHeight;
	}

	Person(int InAge, float InHeight, float InWeight)
	{
		Age = InAge;
		Height = InHeight;
		Weight = InWeight;
	}

private:
	int Age;
	float Height;
	float Weight;
};

int main()
{
	Person p1(10);
	Person p2(20, 164.f);
	Person p3(30, 177.f, 80.f);
}
```

추가로 멤버를 초기화하는 방법에는 **초기화 리스트(Initializer List)**라는 것이 있다. 이는 생성자가 호출되기 전 선언된 멤버에 인자 값을 할당하는 것으로 불필요한 대입 연산을 줄일 수 있다.

```c++
class Person
{
public:
	// 초기화 리스트를 통해 멤버 초기화
	Person(int InAge, float InHeight, float InWeight) : Age(InAge), Height(InHeight), Weight(InWeight)
	{
		// 생성자 내부는 비워도 된다.
	}

	void Print()
	{
		std::cout << "Age: " << Age << std::endl;
		std::cout << "Height: " << Height << std::endl;
		std::cout << "Weight: " << Weight << std::endl;
	}

private:
	int Age;
	float Height;
	float Weight;
};
```

멤버 초기화 과정을 자세하게 살펴보면, 우선 컴파일러가 코드를 훑으며 클래스의 크기를 확인한 후 메모리에 공간을 확보한다. 그리고 생성자가 호출되기 전(생성자 내부 로직 수행 전) **멤버 변수가 생성**되는데, 이때 초기화 리스트를 통해 **생성과 동시에 초기화를 수행**한다. 만약 생성자 내부에서 대입 연산을 통해 초기화하게 되면 **기존의 값 위에 새로운 값을 덮어쓰기** 때문에 작업이 더 늘어나게 된다.

참고로 `C++11` 이후부터는 멤버 선언과 동시에 초기화가 가능하다.

```c++
class Person
{
	// ...

private:
	// 선언과 동시에 초기화
	int Age = 20;
	float Height = 177.f;
	float Weight = 81.f;
};
```

겉으로 보기엔 선언과 동시에 값을 할당하는 것처럼 보이지만, 내부적으로는 초기화 리스트와 같이 동작한다.

### 복사 생성자
**복사 생성자(Copy Constructor)**란 **동일한 타입의 객체를 인자로 전달**받아 전달받은 객체와 동일한 멤버를 구성하는 생성자이다.

특징
- `ClassName(const ClassName& other)` 형태로 구성된다.
- 사용자가 정의하지 않더라도 상황에 따라 컴파일러가 자동 생성한다.
- 자동 생성된 복사 생성자는 **얕은 복사**를 기본으로 한다.

```c++
class Character
{
public:
	Character(float InHP, float InMP)
	{
		// 일반 생성자
	}

	Character(const Character& other) : HP(other.HP), MP(other.MP)
	{
		// 복사 생성자
	}

	void Print()
	{
		std::cout << "HP: " << HP << std::endl;
		std::cout << "MP: " << MP << std::endl;
	}

protected:
	float HP = 0.f;
	float MP = 0.f;
};
```

복사 생성자는 기존에 생성된 객체의 구성을 그대로 복사한다. 생성자 내부에서는 참조 변수를 통해 객체를 전달받아 멤버를 구성한다.

```c++
int main()
{
	Character c1(50.f, 30.f);
	Character c2(c1);			// 복사 생성자 호출
	Character c3 = c1;			// 대입으로도 복사 생성자 호출 가능

	std::cout << "=== c1 ===" << std::endl;
	c1.Print();

	std::cout << std::endl;

	std::cout << "=== c2 ===" << std::endl;
	c2.Print();

	std::cout << std::endl;

	std::cout << "=== c3 ===" << std::endl;
	c3.Print();

	return 0;
}
```

```text
=== c1 ===
HP: 50
MP: 30

=== c2 ===
HP: 50
MP: 30

=== c3 ===
HP: 50
MP: 30
```

여기서 중요한 점은 복사 생성자의 인자가 **참조 변수(`&`)**라는 것이다. `C++`에서 인자를 **값**으로 받는다는 것(Pass by Value)은 ***매개변수에 원본의 값을 복사해서 새로운 변수를 만든다***는 의미이다. 그렇기 때문에 만약 객체 타입을 그대로 인자로 넘길 경우 이를 위한 복사를 수행하게 되어 **무한 루프**에 빠지게 된다.

> 이를 방지하고자 컴파일러는 생성자에서 클래스 타입을 그대로 인자로 받을 수 없도록 컴파일 에러를 발생시킨다.
{: .prompt-info}

컴파일러가 제공하는 복사 생성자는 **얕은 복사(Shallow Copy)**만을 수행한다. 그렇기 때문에 만약 멤버에 포인터 변수가 있다면 심각한 문제를 발생시킨다.

```c++
class Weapon
{

};

class Character
{
public:
	Character(float InHP, float InMP)
	{
		MyWeapon = new Weapon;
	}

	Character(const Character& other) : HP(other.HP), MP(other.MP), MyWeapon(other.MyWeapon)
	{
	}

	void Print()
	{
		std::cout << "HP: " << HP << std::endl;
		std::cout << "MP: " << MP << std::endl;

		std::cout << "Weapon: " << MyWeapon << std::endl;
	}

	~Character()
	{
		if (MyWeapon != nullptr)
			delete MyWeapon;
	}

protected:
	float HP = 0.f;
	float MP = 0.f;

	Weapon* MyWeapon = nullptr;
};
```

`Character` 클래스에 `Weapon` 포인터 변수를 추가했다. 그리고 일반 생성자 내부에 동적 할당을 통해 해당 변수를 할당한다.

> 동적 할당은 반드시 해제해야 한다.
{: .prompt-info}

복사 생성자가 호출될 때 포인터 변수에 원본의 포인터 변수로 초기화했다. 즉, **같은 메모리 공간**을 바라보게 되는 것이다. 그렇기에 원본과 복사된 객체가 존재하고, 둘 중 사용이 끝난 객체가 소멸되었다고 했을 때, 포인터 변수가 가리키는 공간 역시 해제된다. 이렇게 되면 후에 남은 객체가 소멸될 때 **이미 해제한 공간을 다시 해제(Double Free)** 시도하기 때문에 프로그램에 크래시가 발생한다.

이를 해결하기 위해서는 **깊은 복사(Deep Copy)**를 수행해야 한다.

```c++
class Weapon
{
	// 멤버에 직접 접근 가능하도록 friend 처리
	friend class Character;

private:
	float Endurance = 0.f;
};

class Character
{
public:
	Character(float InHP, float InMP) : HP(InHP), MP(InMP)
	{
		MyWeapon = new Weapon();
		MyWeapon->Endurance = 100.f;	// 데이터 세팅
	}

	Character(const Character& other) : HP(other.HP), MP(other.MP)
	{
		// 깊은 복사 수행
		if (MyWeapon == nullptr)
			MyWeapon = new Weapon(*other.MyWeapon);		// 복사 생성자를 통해 값을 할당 (컴파일러가 자동 생성)
	}

	void Print()
	{
		std::cout << "HP: " << HP << std::endl;
		std::cout << "MP: " << MP << std::endl;

		std::cout << "Weapon Endurance: " << MyWeapon->Endurance << std::endl;
	}

	~Character()
	{
		if (MyWeapon != nullptr)
			delete MyWeapon;
	}

protected:
	float HP = 0.f;
	float MP = 0.f;

	Weapon* MyWeapon = nullptr;
};
```

이렇게 되면 각 객체의 포인터 변수가 바라보는 공간이 다르기 때문에 메모리를 해제하더라도 문제가 발생하지 않는다. 추가로 데이터 역시 복사 생성자를 통해 깔끔하게 복사된다.

<!-- ### 이동 생성자 -->

## 소멸자
생성자에서는 동적 할당을 통해 멤버를 초기화하는 것도 가능하다.

```c++
class Person
{
public:
	Person(const char* InName)
	{
		int Len = strlen(InName) + 1;

		Name = new char[Len];
		strcpy_s(Name, Len, InName);
	}

private:
	char* Name = nullptr;
};
```

동적 할당한 메모리는 사용 후 반드시 할당을 해제하여 메모리 누수를 방지해야 한다. C++에서는 이를 위해 **소멸자(Destructor)**를 제공한다.

특징
- 생성자와 마찬가지로 클래스와 똑같은 이름을 가지며, 앞에 `~`를 붙인다.
- 객체가 소멸될 때 자동으로 호출된다.
- 인자를 가질 수 없으며 오버로딩 또한 불가능하다.
- 사용자가 추가하지 않아도 컴파일러가 자동으로 호출해준다.

위 클래스에서 소멸자를 통해 메모리를 해제한다면 다음처럼 가능하다.

```c++
class Person
{
public:
	Person(const char* InName)
	{
		int Len = strlen(InName) + 1;

		Name = new char[Len];
		strcpy_s(Name, Len, InName);
	}

  ~Person()
	{
		delete[] Name;  // 소멸자를 통해 동적 할당된 메모리를 해제
	}

private:
	char* Name = nullptr;
};
```