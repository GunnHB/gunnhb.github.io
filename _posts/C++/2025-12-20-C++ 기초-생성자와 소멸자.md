---
title: "[C++ 기초] 생성자와 소멸자"
description: C++의 다양한 생성자와 소멸자
date: 2025-12-20 00:00:00 +09:00
categories: [Programming, C++]
tags:
  [
    Programming,
    C++,
  ]
---

> 공부한 내용을 정리한 글입니다.

## 생성자
**생성자(Constructor)**는 클래스의 인스턴스를 생성할 때 **가장 먼저 호출**되는 특별한 함수이다. 주로 멤버의 초기화하거나 필요한 리소스를 할당하는 역할을 한다.

특징
- 클래스와 똑같은 이름을 가진다.
- 반환 타입이 없다.
- 객체가 생성될 때 딱 한 번 호출된다.

사실 멤버의 초기화는 사용자 정의 함수를 통해서도 가능하다. 다음과 같은 클래스가 있다고 가정하자.

```c++
class Person
{
	int Age;

public:
	void SetAge(int InAge)
	{
		Age = InAge;
	}

	void Print()
	{
		std::cout << "Age: " << Age << std::endl;
	}
};
```

클래스의 멤버 변수인 `Age`는 멤버 함수인 `SetAge`를 통해 초기화된다. 그리고 `Print` 함수를 호출하면 `Age`의 값이 나오게 된다.

```c++
int main()
{
	Person person;

	person.SetAge(10);
	person.Print();

	return 0;
}
```

```text
Age: 10
```

하지만 `SetAge` 함수를 만들지 않거나 호출하지 않으면 `Age`에는 쓰레기 값이 들어있게 된다.

```c++
int main()
{
	Person person;

	person.Print();

	return 0;
}
```

```text
Age: -858993460
```

물론 `Setter` 함수를 만들고 호출하기만 한다면 아무 문제 없다. 하지만 사람은 누구나 실수하고 클래스를 만들 때마다 해당 함수를 만드는 것도 번거롭다. 이를 위해 **생성자를 사용**하는 것이다.

위 코드에 멤버 변수를 초기화하는 생성자를 추가하면 다음과 같다.

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

private:
	int Age;

public:
	void Print()
	{
		std::cout << "Age: " << Age << std::endl;
	}
};
```

이렇게 하면 객체를 생성하면서 멤버를 바로 초기화할 수 있게 된다.

```c++
int main()
{
	Person person(30);
	person.Print();

	return 0;
}
```

```text
Age: 30
```

## 디폴트 생성자
위에서 생성자는 객체를 생성할 때 가장 먼저 호출되는 함수라고 했다. 하지만 클래스에 생성자를 만들어주지 않아도 생성자가 호출되는데, 이는 컴파일러가 자동으로 추가해주는 `디폴트 생성자(Default Constructor)`가 호출되기 때문이다.

```c++
class Person
{
private:
	int Age;
};

int main()
{
	Person person;  // 컴파일러가 만들어준 디폴트 생성자 호출
}
```

> `Person person()`처럼 객체를 생성해서는 안된다. 컴파일러는 이를 `Person` 타입의 `person` 함수를 선언하는 것으로 인식한다.
{: .prompt-warning}

디폴트 생성자는 매개 변수가 없는 생성자를 말한다. 이는 사용자가 직접 추가할 수도 있다.

```c++
class Person
{
public:
  Person()
  {
    // 사용자가 추가한 디폴트 생성자
  }

private:
	int Age;
};
```

언급한 것처럼 **생성자가 없을 경우** 컴파일러가 자동으로 추가한다고 했다. 만약 사용자가 어떠한 생성자를 추가했다면 컴파일러는 **디폴트 생성자를 추가하지 않는다.**

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

private:
	int Age;
};

int main()
{
	Person person;  // 디폴트 생성자가 생성되지 않아 컴파일 에러 발생!

	return 0;
}
```

## 생성자 오버로딩
생성자는 함수이다. 즉 생성자 역시 **오버로딩(overloading)**이 가능하다.

```c++
class Person
{
public:
	Person(int InAge)
	{
		Age = InAge;
	}

	Person(int InAge, float InHeight)
	{
		Age = InAge;
		Height = InHeight;
	}

	Person(int InAge, float InHeight, float InWeight)
	{
		Age = InAge;
		Height = InHeight;
		Weight = InWeight;
	}

private:
	int Age;
	float Height;
	float Weight;
};

int main()
{
	Person p1(10);
	Person p2(20, 164.f);
	Person p3(30, 177.f, 80.f);
}
```

그렇기 때문에 특정 **멤버만을 초기화**하는 생성자를 추가할 수 있다. 하지만 앞서 말한 것처럼 초기화되지 않은 멤버에는 쓰레기 값이 들어가게 된다. 그렇기 때문에 안전성을 위해 멤버 선언 시 초기화해주는 것이 좋다.

```c++
class Person
{
  // ...

private:
	int Age = 0;
	float Height = 0.f;
	float Weight = 0.f;
};
```

> 생성자 내부에서 멤버를 초기화할 수 있지만 **코드의 중복**을 줄이고 **실수를 방지**하기 위해 선언과 동시에 초기화하는 것이 좋다.
{: .prompt-info}

## 소멸자
생성자에서는 동적 할당을 통해 멤버를 초기화하는 것도 가능하다.

```c++
class Person
{
public:
	Person(const char* InName)
	{
		int Len = strlen(InName) + 1;

		Name = new char[Len];
		strcpy_s(Name, Len, InName);
	}

private:
	char* Name = nullptr;
};
```

동적 할당한 메모리는 사용 후 반드시 할당을 해제하여 메모리 누수를 방지해야 한다. C++에서는 이를 위해 **소멸자(Destructor)**를 제공한다.

특징
- 생성자와 마찬가지로 클래스와 똑같은 이름을 가지며, 앞에 `~`를 붙인다.
- 객체가 소멸될 때 자동으로 호출된다.
- 인자를 가질 수 없으며 오버로딩 또한 불가능하다.
- 사용자가 추가하지 않아도 컴파일러가 자동으로 호출해준다.

위 클래스에서 소멸자를 통해 메모리를 해제한다면 다음처럼 가능하다.

```c++
class Person
{
public:
	Person(const char* InName)
	{
		int Len = strlen(InName) + 1;

		Name = new char[Len];
		strcpy_s(Name, Len, InName);
	}

  ~Person()
	{
		delete[] Name;  // 소멸자를 통해 동적 할당된 메모리를 해제
	}

private:
	char* Name = nullptr;
};
```