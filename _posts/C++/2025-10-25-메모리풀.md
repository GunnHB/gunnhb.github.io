---
title: "[C++] 메모리 풀"
description: 고정 크기 메모리 풀 설명과 구현
date: 2025-11-08 00:00:00 +09:00
categories: [Programming, C++]
tags:
  [
    Programming,
    C++,
  ]
---

> 공부한 내용을 정리한 글입니다.

## 개요
일반적으로 C++에서 동적 할당은 `new`나 `malloc`을 이용한다. 하지만 힙에 할당되는 메모리는 차곡차곡 정리되는 것이 아닌 운영체제가 임의의 위치에 필요한 크기만큼 공간을 할당하는 것이기에 잦은 동적 할당은 **메모리 단편화**를 유발시켜 성능에 영향을 준다. 이를 해결하기 위해 **메모리 풀(Memory Pool)**이라 불리는 일정 크기의 메모리 블록을 미리 할당해 단편화를 방지한다.

> 고정 크기 메모리 풀은 충분한 크기의 공간을 잡은 뒤 해당 공간을 일정 크기로 쪼개어 관리하는 방식이다. 할당과 해제로 인한 외부 단편화를 방지할 수 있지만, 객체의 크기에 따라 오히려 메모리를 낭비할 수 있다.
{: .prompt-info }

## Memory Pool

### 멤버 변수
```c++
class memory_pool
{
private:
	char* pool = nullptr;
	size_t pool_size = 0;
	size_t block_size = 0;
	std::vector<bool> used;
	size_t total_blocks = 0;
};
```

클래스의 멤버 변수는 다음과 같다.

- `char* pool = nullptr;`
	- 풀의 시작 주소
	- 후술하겠지만 `char`는 1byte 크기를 보장하기 때문에 포인터 연산이 직관적이다.

- `size_t pool_size = 0;`
	- 메모리 공간의 총 크기

- `size_t block_size = 0;`
	- 개별 블록의 크기

- `std::vector<bool> used;`
	- 메모리 블록의 사용 여부를 확인하기 위한 벡터

- `size_t total_blocks = 0;`
	- 메모리 블록의 총 개수

### 생성자와 소멸자
```c++
public:
	memory_pool(size_t in_pool_size, size_t in_block_size) : pool_size(in_pool_size), block_size(in_block_size)
	{
		total_blocks = in_pool_size / in_block_size;

		pool = new char[pool_size];
		used.resize(total_blocks, false);

		std::cout << "메모리 풀 생성: " << in_pool_size << "byte: " << total_blocks << "block" << "\n";
	}

	~memory_pool()
	{
		delete[] pool;

		std::cout << "메모리 풀 해제" << "\n";
	}
```

생성자에서는 전체 풀 크기와 블록의 크기를 초기화한 후 풀 크기만큼의 연속된 공간을 할당받는다. 참고로 만약 풀 크기가 블록 크기로 나누어 떨어지지 않으면 남는 자투리 공간은 풀에 할당은 되지만 사용되지는 않는다.

소멸자에서는 할당받았던 공간을 해제해준다. 당연하지만 해제하지 않으면 메모리 누수가 일어나게 된다.

### allocate()

```c++
void* memory_pool::allocate()
{
	for (size_t index = 0; index < total_blocks; ++index)
	{
		if (used[index] == false)
		{
			used[index] = true;

			char* block_add = pool + (index * block_size);

			std::cout << index << " block" << " is assigned at " << static_cast<void*>(block_add) << "\n";

			return block_add;
		}
	}

	std::cout << "out of pool!" << "\n";
	return nullptr;
}
```

`allocate`는 총 블록 개수만큼 순회하면서 미사용 중인 블록을 찾아 해당 블록의 주소를 반환한다. 만약 모든 공간을 사용 중이라면 nullptr을 반환한다.

> `void*`는 **범용 포인터**이다. 어떤 타입의 변수 주소든지 저장할 수 있지만 타입 정보가 없기 때문에 역참조가 불가능하다.
{: .prompt-info}

참고로 포인터 연산은 타입에 따라 다르게 연산된다. 만약 `int* p = new int;` 일 때 (`sizeof(int)`는 4byte라고 가정) `p + 1`은 **해당 주소의 4byte 뒤**를 의미하는데, 이는 `int` 배열에서의 이웃 원소를 가리키기 위함이다. 그렇기에 `char*`를 사용하면 1byte씩 더해가므로 연산이 간편하다.

### deallocate()

```c++
void memory_pool::deallocate(void* ptr)
{
	if (ptr == nullptr)
		return;

	char* char_ptr = static_cast<char*>(ptr);

	if (char_ptr < pool || char_ptr >= pool + pool_size)
	{
		std::cout << "it's not valid" << "\n";
		return;
	}

	size_t block_index = (char_ptr - pool) / block_size;

	if (block_index < total_blocks && used[block_index])
	{
		used[block_index] = false;
		std::cout << block_index << " block deallocate" << "\n";
	}
	else
		std::cout << "already deallocated or wrong address!" << "\n";
}
```

`deallocate`는 사용했던 메모리 블록을 반납한다. 범용 포인터를 `char*` 타입으로 캐스팅하여 시작 주소로부터 몇 byte만큼 떨어져있는지 확인한다. 만약 주소 값이 풀의 범위 밖이라면 유효하지 않은 공간으로 처리하고, 그렇지 않다면 해당 주소가 몇 번째 블록인지 확인하여 반납한다.

### print_status()

```c++
void memory_pool::print_status()
{
	int used_count = 0;
	for (bool is_used : used)
	{
		if (is_used)
			++used_count;
	}

	std::cout << "\n === memory status ===" << "\n";
	std::cout << "total blocks: " << total_blocks << "\n";
	std::cout << "used count: " << used_count << "\n";
	std::cout << "useable block: " << (total_blocks - used_count) << "\n\n";

	std::cout << "block usage: ";
	for (size_t index = 0; index < total_blocks; ++index)
		std::cout << (used[index] ? "■" : "□");
	std::cout << "\n\n";
}
```

`print_status`는 풀의 상태를 확인한다. 총 블록의 수와 블록의 사용 여부를 시각적으로 보여준다.

## 사용 예시

이렇게 만든 메모리 풀은 다음과 같이 사용할 수 있다.

```c++
#include <iostream>

#include "memory_pool.h"

int main()
{
	memory_pool mp(32, 4);

	void* t = mp.allocate();
	mp.print_status();

	mp.deallocate(t);
	mp.print_status();

	return 0;
}
```

메모리 풀 선언 시 총 풀 크기와 블록의 크기를 지정해준다. 그런 다음 사용 가능한 블록의 주소를 반환받는다. 그 후 사용이 끝나면 다시 범용 포인터를 이용해 반납한다. 위 코드를 실행하면 다음과 같은 결과를 얻을 수 있다.

```
메모리 풀 생성: 32byte: 8block
0 block is assigned at 00000276ACA512D0

 === memory status ===
total blocks: 8
used count: 1
useable block: 7

block usage: ■□□□□□□□

0 block deallocate

 === memory status ===
total blocks: 8
used count: 0
useable block: 8

block usage: □□□□□□□□

메모리 풀 해제
```

> 만약 객체에 값을 넣고 싶다면 범용 포인터를 원하는 타입으로 캐스팅해 값을 할당하면 된다.
{: .prompt-info}

또한 일반 타입뿐만 아닌 클래스 역시 사용할 수 있다.

```c++
#include <iostream>

#include "memory_pool.h"

class CMemory
{
public:
	CMemory(){ }

	int int_value;
	float float_value;
	char char_value;

public:
	void print()
	{
		std::cout << "\n" << "int value: " << int_value << "\n";
		std::cout << "float value: " << float_value << "\n";
		std::cout << "char value: " << char_value << "\n";
	}
};

int main()
{
	memory_pool mp(256, 32);

	void* t = mp.allocate();
	CMemory* mem = static_cast<CMemory*>(t);

	mem->int_value = 1;
	mem->float_value = 10.f;
	mem->char_value = 'a';

	mem->print();
	mp.print_status();

	return 0;
}
```

기본적인 동작 방식은 동일하며, 단순히 타입이 클래스로 바뀐 것 뿐이다. 결과를 확인하면 다음과 같다.

```
메모리 풀 생성: 256byte: 8block
0 block is assigned at 00000243431A5AD0

int value: 1
float value: 10
char value: a

 === memory status ===
total blocks: 8
used count: 1
useable block: 7

block usage: ■□□□□□□□

메모리 풀 해제
```

> 풀과 블록의 크기만 충분하다면 배열 역시 할당 가능하다.
{: .prompt-info}

## 마무리

위에서 언급한 것처럼 메모리 풀은 외부 단편화를 방지할 수 있는 메모리 관리 방법 중 하나이다. 다만 객체의 크기가 블록의 크기보다 작은 경우 오히려 메모리를 낭비하게 되니 상황에 따라 적절하게 사용하면 될 것 같다.