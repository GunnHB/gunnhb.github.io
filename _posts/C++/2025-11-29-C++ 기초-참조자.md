---
title: "[C++ 기초] 참조자"
description: C++의 참조자(레퍼런스)
date: 2025-11-29 00:00:00 +09:00
categories: [Programming, C++]
tags:
  [
    Programming,
    C++,
  ]
---

> 공부한 내용을 정리한 글입니다.

## 참조자
일반적으로 **변수(variable)**는 일정 크기만큼 할당된 공간에 대한 이름을 뜻한다. 그렇기에 사용자는 이 이름을 통해 메모리 공간에 접근할 수 있게되는 것이다. **참조자(Reference)**는 이 공간에 대해 **또 다른 이름**을 붙이는 것을 뜻한다.

> 타입 뒤에 `&`를 붙이면 참조자로 사용할 수 있다.
{: .prompt-info}

쉬운 예를 하나 들어보자. 다음 영상은 영화배우 짐 캐리(Jim Carrey)가 골든 글러브 시상식에서 던진 유머에 대한 내용이다.

{% include embed/youtube.html id='u-bbMb9VcsM' %}

> 저는 골든 글러브 2회 수상자 짐 캐리입니다.  
> 제가 잠자리에 들면 그냥 잠에 드는 것이 아닙니다.  
> 골든 글러브 2회 수상자 짐 캐리가 잠에 드는 것이죠.

해당 스피치에 따르면 '골든 글러브 2회 수상자'가 잠에 드는 것은 곧 짐 캐리가 잠에 드는 것이다. 짐 캐리와 수상자는 같은 인물이기 때문이다. 이처럼 참조자는 변수에 대한 **별명(Nickname)**을 뜻한다.

```c++
#include <iostream>

int main()
{
	int a = 100;
	int& ref_a = a;

	ref_a = 200;

	std::cout << "a: " << a << std::endl;

	return 0;
}
```

```text
a: 200
```

위 코드를 살펴보면 `a`를 100으로 초기화한 뒤 a에 대한 참조변수 `ref_a`를 선언했다. 그런 다음 `ref_a`의 값에 200을 할당한 뒤 `a`를 출력해보면 200이 출력되는 것을 확인할 수 있다.

이는 `ref_a`가 `a`를 참조하기 때문인데, `ref_a`에 어떤 작업을 해도 `a`에 작업하는 것과 마찬가지이다.

이를 쉽게 이해하기 위해서는 주소 값을 비교해보면 좋다.

```c++
#include <iostream>

int main()
{
	int a = 100;
	int& ref_a = a;

	std::cout << "a 주소: " << &a << std::endl;
	std::cout << "ref_a 주소: " << &ref_a << std::endl;

	return 0;
}
```

```text
a 주소: 000000E69676FC74
ref_a 주소: 000000E69676FC74
```

두 변수의 메모리 주소를 출력해보면 같은 것을 확인할 수 있다. 그러므로 `ref_a`를 수정하는 것은 `a`를 직접 수정하는 것과 같다.

## 참조자를 사용하는 이유
C++에서는 함수에 변수를 전달할 때 일반적으로 **call by value** 방식을 사용한다. 즉, 값을 **복사**하여 전달한다는 것이다. 이는 int와 같은 작은 데이터의 경우 별 문제가 없지만, 크기가 큰 구조체나 클래스의 경우 **복사에 대한 성능 문제가 발생**한다.

```c++
#include <iostream>

class Stat
{
public:
	Stat(float in_hp, float in_mp, float in_exp)
	{
		std::cout << "생성자 호출" << std::endl;

		hp = in_hp;
		mp = in_mp;
		exp = in_exp;
	}

	Stat(const Stat& in_stat)
	{
		std::cout << "복사 생성자 호출" << std::endl;

		hp = in_stat.hp;
		mp = in_stat.mp;
		exp = in_stat.exp;
	}

	float hp;
	float mp;
	float exp;
	
	// ...
};

void UpdateStat(Stat stat)
{
	std::cout << "UpdateStat" << std::endl;

	stat.hp += 10;
}

int main()
{
	Stat newStat(10, 5, 1);
	UpdateStat(newStat);

	return 0;
}
```

```text
생성자 호출
복사 생성자 호출
UpdateStat
```

여기서 만약 참조자를 사용해 전달하게 되면 **call by reference** 방식이 되어 인자로 복사하는 것이 아닌 값을 그대로 사용하게 된다.

```c++
#include <iostream>

class Stat
{
public:
	Stat(float in_hp, float in_mp, float in_exp)
	{
		std::cout << "생성자 호출" << std::endl;

		hp = in_hp;
		mp = in_mp;
		exp = in_exp;
	}

	Stat(const Stat& in_stat)
	{
		std::cout << "복사 생성자 호출" << std::endl;

		hp = in_stat.hp;
		mp = in_stat.mp;
		exp = in_stat.exp;
	}

	float hp;
	float mp;
	float exp;
	
	// ...
};

void UpdateStat(Stat& stat)
{
	std::cout << "UpdateStat" << std::endl;

	stat.hp += 10;
}

int main()
{
	Stat newStat(10, 5, 1);
	UpdateStat(newStat);

	return 0;
}
```

```text
생성자 호출
UpdateStat
```

이렇 듯 원본 데이터를 그대로 수정하여 성능에 영향을 주지 않기 위해 참조자를 사용한다.

> 만약 원본 데이터를 읽기 전용으로 만들고 싶다면 앞에 `const`를 붙이면 된다.
{: .prompt-info}

## 참조자 사용 시 주의사항
위에서 언급했지만 참조자는 변수의 별명이다. 별명은 곧 **대상이 있어야만 존재할 수 있는 것**이다. 이때문에 참조자는 상수나 `NULL`이 될 수 없으며, 초기화 시에 **반드시 참조할 대상을 정해줘야 한다.**

```c++
#include <iostream>

int main()
{
	int& ref_a = 2;			// 상수 참조 불가능
	float& ref_b = NULL;	// NULL 참조 불가능
	char& ref_c;			// 참조 대상이 없으면 선언 불가능
}
```

또한 초기화 시 어떤 대상을 참조했다면 그 **대상을 변경하는 것이 불가능**하다. 별명은 대상이 바뀌면 의미가 사라지게 된다.

```c++
#include <iostream>

int main()
{
	int a = 10;
	int b = 20;

	int& ref_a = a;
	ref_a = b;			// 참조 대상을 b로 바꾸는 것이 아님!

	std::cout << "a: " << a << std::endl;

	return 0;
}
```

```text
a: 20
```

`ref_a`를 선언할 때 `a`를 참조하도록 초기화했다. 그리고 다음 줄에서 `ref_a`에 `b`를 할당하는데, 이는 참조의 대상을 `b`로 변경하는 것이 아닌 단순히 **값을 할당하는 것**이기에 `a`를 출력했을 때 20이 출력되는 것이다.